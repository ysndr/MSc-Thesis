
@inproceedings{abadTaskInterruptionSoftware2018,
  title = {Task {{Interruption}} in {{Software Development Projects}}: {{What Makes}} Some {{Interruptions More Disruptive}} than {{Others}}?},
  shorttitle = {Task {{Interruption}} in {{Software Development Projects}}},
  booktitle = {Proceedings of the 22nd {{International Conference}} on {{Evaluation}} and {{Assessment}} in {{Software Engineering}} 2018},
  author = {Abad, Zahra Shakeri Hossein and Karras, Oliver and Schneider, Kurt and Barker, Ken and Bauer, Mike},
  year = {2018},
  month = jun,
  series = {{{EASE}}'18},
  pages = {122--132},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3210459.3210471},
  url = {https://doi.org/10.1145/3210459.3210471},
  urldate = {2022-03-14},
  abstract = {Multitasking has always been an inherent part of software development and is known as the primary source of interruptions due to task switching in software development teams. Developing software involves a mix of analytical and creative work, and requires a significant load on brain functions, such as working memory and decision making. Thus, task switching in the context of software development imposes a cognitive load that causes software developers to lose focus and concentration while working thereby taking a toll on productivity. To investigate the disruptiveness of task switching and interruptions in software development projects, and to understand the reasons for and perceptions of the disruptiveness of task switching we used a mixed-methods approach including a longitudinal data analysis on 4,910 recorded tasks of 17 professional software developers, and a survey of 132 software developers. We found that, compared to task-specific factors (e.g. priority, level, and temporal stage), contextual factors such as interruption type (e.g. self/external), time of day, and task type and context are a more potent determinant of task switching disruptiveness in software development tasks. Furthermore, while most survey respondents believe external interruptions are more disruptive than self-interruptions, the results of our retrospective analysis reveals otherwise. We found that self-interruptions (i.e. voluntary task switchings) are more disruptive than external interruptions and have a negative effect on the performance of the interrupted tasks. Finally, we use the results of both studies to provide a set of comparative vulnerability and interaction patterns which can be used as a mean to guide decision-making and forecasting the consequences of task switching in software development teams.},
  isbn = {978-1-4503-6403-4},
  keywords = {Empirical software engineering,Multitasking,Productivity,Retrospective analysis,Task interruption,Task switching},
  file = {/Users/ysander/Zotero/storage/IA8QEIVW/Abad et al. - 2018 - Task Interruption in Software Development Projects.pdf}
}

@inproceedings{abadTaskInterruptionSoftware2018a,
  title = {Task {{Interruption}} in {{Software Development Projects}}: {{What Makes}} Some {{Interruptions More Disruptive}} than {{Others}}?},
  shorttitle = {Task {{Interruption}} in {{Software Development Projects}}},
  booktitle = {Proceedings of the 22nd {{International Conference}} on {{Evaluation}} and {{Assessment}} in {{Software Engineering}} 2018},
  author = {Abad, Zahra Shakeri Hossein and Karras, Oliver and Schneider, Kurt and Barker, Ken and Bauer, Mike},
  year = {2018},
  month = jun,
  pages = {122--132},
  publisher = {{ACM}},
  address = {{Christchurch New Zealand}},
  doi = {10.1145/3210459.3210471},
  url = {https://dl.acm.org/doi/10.1145/3210459.3210471},
  urldate = {2022-03-14},
  abstract = {Multitasking has always been an inherent part of so ware development and is known as the primary source of interruptions due to task switching in so ware development teams. Developing so ware involves a mix of analytical and creative work, and requires a signi cant load on brain functions, such as working memory and decision making. us, task switching in the context of so ware development imposes a cognitive load that causes so ware developers to lose focus and concentration while working thereby taking a toll on productivity. To investigate the disruptiveness of task switching and interruptions in so ware development projects, and to understand the reasons for and perceptions of the disruptiveness of task switching we used a mixed-methods approach including a longitudinal data analysis on 4,910 recorded tasks of 17 professional so ware developers, and a survey of 132 so ware developers. We found that, compared to task-speci c factors (e.g. priority, level, and temporal stage), contextual factors such as interruption type (e.g. self/external), time of day, and task type and context are a more potent determinant of task switching disruptiveness in so ware development tasks. Furthermore, while most survey respondents believe external interruptions are more disruptive than self-interruptions, the results of our retrospective analysis reveals otherwise. We found that self-interruptions (i.e. voluntary task switchings) are more disruptive than external interruptions and have a negative e ect on the performance of the interrupted tasks. Finally, we use the results of both studies to provide a set of comparative vulnerability and interaction pa erns which can be used as a mean to guide decision-making and forecasting the consequences of task switching in so ware development teams.},
  isbn = {978-1-4503-6403-4},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/27AV3E53/Abad et al. - 2018 - Task Interruption in Software Development Projects.pdf}
}

@misc{AllDeveloperTools,
  title = {All {{Developer Tools}} and {{Products}} by {{JetBrains}}},
  journal = {JetBrains},
  url = {https://www.jetbrains.com/products/},
  urldate = {2022-02-19},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/72YCIQTQ/products.html}
}

@misc{amannRustDynamicDispatching2020,
  title = {Rust {{Dynamic Dispatching}} Deep-Dive},
  author = {Amann, Marco},
  year = {2020},
  month = feb,
  journal = {Digital Frontiers{$\mkern1mu$}\textemdash{$\mkern1mu$}Das Blog},
  url = {https://medium.com/digitalfrontiers/rust-dynamic-dispatching-deep-dive-236a5896e49b},
  urldate = {2021-10-19},
  abstract = {Rust praises itself as being capable of creating some of the fastest executables, but does this hold for dynamic dispatching? A deep-dive.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/T94HTCH4/rust-dynamic-dispatching-deep-dive-236a5896e49b.html}
}

@misc{ArchitectureOpenSource,
  title = {The {{Architecture}} of {{Open Source Applications}}: {{LLVM}}},
  url = {http://www.aosabook.org/en/llvm.html},
  urldate = {2022-02-24},
  file = {/Users/ysander/Zotero/storage/CCH2G8TR/llvm.html}
}

@misc{authoritySetuptoolsEasilyDownload,
  title = {Setuptools: {{Easily}} Download, Build, Install, Upgrade, and Uninstall {{Python}} Packages},
  shorttitle = {Setuptools},
  author = {Authority, Python Packaging},
  url = {https://github.com/pypa/setuptools},
  urldate = {2022-01-02},
  copyright = {MIT License},
  keywords = {CPAN;,distutils;,eggs;,management,package;,PyPI;,Software Development - Libraries - Python Modules,System - Archiving - Packaging,System - Systems Administration,Utilities}
}

@misc{AWSConsoleSignup,
  title = {{{AWS Console}} - {{Signup}}},
  url = {https://portal.aws.amazon.com/billing/signup#/start},
  urldate = {2022-01-03}
}

@book{bettiniImplementingDomainspecificLanguages2016,
  title = {Implementing Domain-Specific Languages with {{Xtext}} and {{Xtend}}: Learn How to Implement a {{DSL}} with {{Xtext}} and {{Xtend}} Using Easy-to-Understand Examples and Best Practices},
  shorttitle = {Implementing Domain-Specific Languages with {{Xtext}} and {{Xtend}}},
  author = {Bettini, Lorenzo and Efftinge, Sven},
  year = {2016},
  series = {Packt Open Source Community Experience Distilled},
  edition = {Second edition},
  publisher = {{Packt Publishing}},
  address = {{Birmingham Mumbai}},
  isbn = {978-1-78646-496-5},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/I9NIWQ47/Bettini and Efftinge - 2016 - Implementing domain-specific languages with Xtext .pdf}
}

@article{beyerCPAcheckerToolConfigurable2009,
  title = {{{CPAchecker}}: {{A Tool}} for {{Configurable Software Verification}}},
  shorttitle = {{{CPAchecker}}},
  author = {Beyer, Dirk and Keremoglu, M. Erkan},
  year = {2009},
  month = jan,
  journal = {arXiv:0902.0019 [cs]},
  eprint = {0902.0019},
  eprinttype = {arxiv},
  primaryclass = {cs},
  url = {http://arxiv.org/abs/0902.0019},
  urldate = {2022-02-24},
  abstract = {Configurable software verification is a recent concept for expressing different program analysis and model checking approaches in one single formalism. This paper presents CPAchecker, a tool and framework that aims at easy integration of new verification components. Every abstract domain, together with the corresponding operations, is required to implement the interface of configurable program analysis (CPA). The main algorithm is configurable to perform a reachability analysis on arbitrary combinations of existing CPAs. The major design goal during the development was to provide a framework for developers that is flexible and easy to extend. We hope that researchers find it convenient and productive to implement new verification ideas and algorithms using this platform and that it advances the field by making it easier to perform practical experiments. The tool is implemented in Java and runs as command-line tool or as Eclipse plug-in. We evaluate the efficiency of our tool on benchmarks from the software model checker BLAST. The first released version of CPAchecker implements CPAs for predicate abstraction, octagon, and explicit-value domains. Binaries and the source code of CPAchecker are publicly available as free software.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages,Computer Science - Software Engineering,D.2.4,F.3.1},
  file = {/Users/ysander/Zotero/storage/2D6KGBDE/Beyer and Keremoglu - 2009 - CPAchecker A Tool for Configurable Software Verif.pdf;/Users/ysander/Zotero/storage/NKETYEQT/0902.html}
}

@misc{beyerCPAcheckerVerifierCloud,
  title = {{{CPAchecker In}} the {{VerifierCloud}}},
  author = {Beyer, Dirk},
  url = {https://vcloud.sosy-lab.org/cpachecker/webclient/help/},
  urldate = {2022-02-24},
  howpublished = {Software Systems Lab LMU},
  file = {/Users/ysander/Zotero/storage/VJXFLWW4/help.html}
}

@book{beyerSiteReliabilityWorkbook2018,
  title = {The {{Site Reliability Workbook}}: {{Practical Ways}} to {{Implement SRE}}},
  shorttitle = {The {{Site Reliability Workbook}}},
  author = {Beyer, Betsy and Murphy, Niall Richard and Rensin, David K. and Kawahara, Kent and Thorne, Stephen},
  year = {2018},
  month = jul,
  publisher = {{"O'Reilly Media, Inc."}},
  abstract = {In 2016, Google's Site Reliability Engineering book ignited an industry discussion on what it means to run production services today\textemdash and why reliability considerations are fundamental to service design. Now, Google engineers who worked on that bestseller introduce The Site Reliability Workbook, a hands-on companion that uses concrete examples to show you how to put SRE principles and practices to work in your environment.This new workbook not only combines practical examples from Google's experiences, but also provides case studies from Google's Cloud Platform customers who underwent this journey. Evernote, The Home Depot, The New York Times, and other companies outline hard-won experiences of what worked for them and what didn't.Dive into this workbook and learn how to flesh out your own SRE practice, no matter what size your company is.You'll learn:How to run reliable services in environments you don't completely control\textemdash like cloudPractical applications of how to create, monitor, and run your services via Service Level ObjectivesHow to convert existing ops teams to SRE\textemdash including how to dig out of operational overloadMethods for starting SRE from either greenfield or brownfield},
  googlebooks = {fElmDwAAQBAJ},
  isbn = {978-1-4920-2945-8},
  langid = {english}
}

@incollection{beyerSoftwareVerificationGoogle2014,
  title = {Software {{Verification}} in the {{Google App-Engine Cloud}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Beyer, Dirk and Dresler, Georg and Wendler, Philipp},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Kobsa, Alfred and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Terzopoulos, Demetri and Tygar, Doug and Weikum, Gerhard and Biere, Armin and Bloem, Roderick},
  year = {2014},
  volume = {8559},
  pages = {327--333},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-08867-9_21},
  url = {http://link.springer.com/10.1007/978-3-319-08867-9_21},
  urldate = {2022-02-24},
  abstract = {Software verification often requires a large amount of computing resources. In the last years, cloud services emerged as an inexpensive, flexible, and energy-efficient source of computing power. We have investigated if such cloud resources can be used effectively for verification. We chose the platform-as-a-service offer Google App Engine and ported the open-source verification framework CPAchecker to it. We provide our new verification service as a web front-end to users who wish to solve single verification tasks (tutorial usage), and an API for integrating the service into existing verification infrastructures (massively parallel bulk usage). We experimentally evaluate the effectiveness of this service and show that it can be successfully used to offload verification work to the cloud, considerably sparing local verification resources.},
  isbn = {978-3-319-08866-2 978-3-319-08867-9},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/H6THGF84/Beyer et al. - 2014 - Software Verification in the Google App-Engine Clo.pdf}
}

@article{birrellImplementingRemoteProcedure1984,
  title = {Implementing {{Remote Procedure Calls}}},
  author = {Birrell, Andrew D and Nelson, Bruce Jay},
  year = {1984},
  journal = {ACM Transactions on Computer Systems},
  volume = {2},
  number = {1},
  pages = {21},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/DTAFTJ6N/Birrell and Nelson - 1984 - Implementing Remote Procedure Calls.pdf}
}

@misc{BlazingFastCloud,
  title = {Blazing Fast Cloud Developer Environments},
  journal = {GitHub},
  url = {https://github.com/features/codespaces},
  urldate = {2021-12-21},
  abstract = {Codespaces has the full power of Visual Studio Code, including the editor, terminal, debugger, settings sync, and any extension.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/JXXGJSKB/codespaces.html}
}

@article{bourMerlinLanguageServer2018a,
  title = {Merlin: {{A Language Server}} for {{OCaml}} ({{Experience Report}})},
  shorttitle = {Merlin},
  author = {Bour, Fr{\'e}d{\'e}ric and Refis, Thomas and Scherer, Gabriel},
  year = {2018},
  month = jul,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {2},
  number = {ICFP},
  eprint = {1807.06702},
  eprinttype = {arxiv},
  pages = {1--15},
  issn = {2475-1421},
  doi = {10.1145/3236798},
  url = {http://arxiv.org/abs/1807.06702},
  urldate = {2021-11-12},
  abstract = {We report on the experience of developing Merlin, a language server for the OCaml programming language in development since 2013. Merlin is a daemon that connects to your favourite text editor and provides services that require a fine-grained understanding of the programming language syntax and static semantics: instant feedback on warnings and errors, autocompletion, `type of the code under the cursor', `go to definition', etc. Language servers need to handle incomplete and partially-incorrect programs, and try to be incremental to minimize recomputation after small editing actions. Merlin was built by carefully adapting the existing tools (the OCamllex lexer and Menhir parser generators) to better support incrementality, incompleteness and error handling. These extensions are elegant and general, as demonstrated by the interesting, unplanned uses that the OCaml community found for them. They could be adapted to other frontends -- in any language. Besides incrementality, we discuss the way Merlin communicates with editors, describe the design decisions that went into some demanding features and report on some of the non-apparent difficulties in building good editor support, emerging from expressive programming languages or frustrating tooling ecosystems. We expect this experience report to be of interest to authors of interactive language tooling for any programming language; many design choices may be reused, and some hard-won lessons can serve as warnings.},
  archiveprefix = {arXiv},
  langid = {english},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/ysander/Zotero/storage/GSC8FGYR/Bour et al. - 2018 - Merlin A Language Server for OCaml (Experience Re.pdf}
}

@misc{BrowseSearchPackages,
  title = {Browse and Search Packages | {{Hackage}}},
  url = {https://hackage.haskell.org/packages/browse?terms=hls},
  urldate = {2022-05-23},
  file = {/Users/ysander/Zotero/storage/BWBSGX4B/browse.html}
}

@book{bucchiaroneDomainSpecificLanguagesPractice2021,
  title = {Domain-{{Specific Languages}} in {{Practice}}: With {{JetBrains MPS}}},
  shorttitle = {Domain-{{Specific Languages}} in {{Practice}}},
  editor = {Bucchiarone, Antonio and Cicchetti, Antonio and Ciccozzi, Federico and Pierantonio, Alfonso},
  year = {2021},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-73758-0},
  url = {https://link.springer.com/10.1007/978-3-030-73758-0},
  urldate = {2022-05-08},
  isbn = {978-3-030-73757-3 978-3-030-73758-0},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/37UK94ZK/Bucchiarone et al. - 2021 - Domain-Specific Languages in Practice with JetBra.pdf}
}

@misc{BuildingLSIFIndexer,
  title = {Building an {{LSIF Indexer}} for a {{Low-Code Platform}}},
  journal = {Airkit},
  url = {https://www.airkit.com/building-language-server-index-format-indexer/},
  urldate = {2022-02-17},
  abstract = {Engineer Brian Shih shares his thoughts on what low-code is and takes us on his journey of building a LSIF (Language Server Index Format) indexer},
  langid = {american},
  keywords = {rw}
}

@inproceedings{bunderDecouplingLanguageEditor2019,
  title = {Decoupling {{Language}} and {{Editor}} - {{The Impact}} of the {{Language Server Protocol}} on {{Textual Domain-Specific Languages}}:},
  shorttitle = {Decoupling {{Language}} and {{Editor}} - {{The Impact}} of the {{Language Server Protocol}} on {{Textual Domain-Specific Languages}}},
  booktitle = {Proceedings of the 7th {{International Conference}} on {{Model-Driven Engineering}} and {{Software Development}}},
  author = {B{\"u}nder, Hendrik},
  year = {2019},
  pages = {129--140},
  publisher = {{SCITEPRESS - Science and Technology Publications}},
  address = {{Prague, Czech Republic}},
  doi = {10.5220/0007556301290140},
  url = {http://www.scitepress.org/DigitalLibrary/Link.aspx?doi=10.5220/0007556301290140},
  urldate = {2021-09-07},
  isbn = {978-989-758-358-2},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/JRD64FEI/Bünder - 2019 - Decoupling Language and Editor - The Impact of the.pdf}
}

@inproceedings{bunderMultieditorSupportDomainSpecific2020,
  title = {Towards {{Multi-editor Support}} for {{Domain-Specific Languages Utilizing}} the {{Language Server Protocol}}},
  booktitle = {Model-{{Driven Engineering}} and {{Software Development}}},
  author = {B{\"u}nder, Hendrik and Kuchen, Herbert},
  editor = {Hammoudi, Slimane and Pires, Lu{\'i}s Ferreira and Seli{\'c}, Bran},
  year = {2020},
  series = {Communications in {{Computer}} and {{Information Science}}},
  pages = {225--245},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-37873-8_10},
  abstract = {In model-driven software development (MDSD) projects, frequently domain experts and developers work together on the same model. However, they have quite different preferences concerning tools for working with a model. While developers require a powerful integrated development environment (IDE), domain experts are overwhelmed by the amount of functionality of an IDE and its confusing user interface. They prefer a simple editor, often provided as a web application, which does not require a local installation. Currently, both stakeholders typically agree on a common tool, which is frustrating for at least one of them. The Language Server Protocol (LSP) is a standard that aims to include language smarts into simple editors without turning them into IDEs. Originally, it has been designed for programming languages. In the present paper, we will give evidence based on a case study and a corresponding SWOT analysis that it is even more beneficial for a textual domain-specific language (DSL) as it is often used in MDSD. We will focus on the language workbench Xtext which supports the LSP. In particular, we will investigate how the LSP can be used to integrate a DSL into different development tools (editors and IDEs). Supplementing the SWOT analysis, we have also evaluated the practical relevance of the LSP.},
  isbn = {978-3-030-37873-8},
  langid = {english},
  keywords = {Case study,Model-driven development language server protocol,Textual domain-specific languages},
  file = {/Users/ysander/Zotero/storage/9Q9JDDBE/Bünder and Kuchen - 2020 - Towards Multi-editor Support for Domain-Specific L.pdf}
}

@book{burnetteEclipseIDEPocket2005,
  title = {Eclipse {{IDE}}: Pocket Guide},
  shorttitle = {Eclipse {{IDE}}},
  author = {Burnette, Ed},
  year = {2005},
  edition = {1st ed},
  publisher = {{O'Reilly}},
  address = {{Sebastopol, CA}},
  isbn = {978-0-596-10065-0},
  lccn = {MLCS 2006/10700 (Q)}
}

@misc{cebronCustomLanguageSupport,
  title = {Custom {{Language Support}}},
  author = {C{\'e}bron, Yann},
  journal = {IntelliJ Platform Plugin SDK Help},
  url = {https://plugins.jetbrains.com/docs/intellij/custom-language-support.html},
  urldate = {2022-02-20},
  langid = {american},
  file = {/Users/ysander/Zotero/storage/BZDZMX5Y/custom-language-support.html}
}

@article{chenEmpiricalStudyProgramming2005,
  title = {An Empirical Study of Programming Language Trends},
  author = {Chen, Yaofei and Dios, R. and Mili, A. and Wu, Lan and Wang, Kefei},
  year = {2005},
  month = may,
  journal = {IEEE Software},
  volume = {22},
  number = {3},
  pages = {72--79},
  issn = {1937-4194},
  doi = {10.1109/MS.2005.55},
  abstract = {Predicting software engineering trends is a strategically important asset for both developers and managers, but it's also difficult, due to the wide range of factors involved and the complexity of their interactions. This paper reveals some interesting trends and a method for studying other important software engineering trends. This article trades breadth for depth by focusing on a small, compact set of trends involving 17 high-level programming languages. We quantified many of their relevant factors, and then collected data on their evolution over 10 years. By applying statistical methods to this data, we aim to gain insight into what does and does not make a language successful.},
  keywords = {Computer languages,empirical software engineering,Engineering management,History,ISO standards,Java,programming languages,Programming profession,Software development management,Software engineering,software engineering trends,statistical modeling},
  file = {/Users/ysander/Zotero/storage/ZS4FW7Y5/Chen et al. - 2005 - An empirical study of programming language trends.pdf;/Users/ysander/Zotero/storage/HTAG5DY9/1438333.html}
}

@misc{ClangLanguageFamily,
  title = {Clang {{C Language Family Frontend}} for {{LLVM}}},
  url = {https://clang.llvm.org/},
  urldate = {2022-05-01},
  file = {/Users/ysander/Zotero/storage/P72RNFNP/clang.llvm.org.html}
}

@misc{CodenvyMicrosoftRed2016,
  title = {Red {{Hat}}, {{Codenvy}} and {{Microsoft Collaborate}} on {{Language Server Protocol}}},
  author = {{Red Hat}},
  year = {2016},
  month = jun,
  url = {https://www.redhat.com/en/about/press-releases/red-hat-codenvy-and-microsoft-collaborate-language-server-protocol},
  urldate = {2022-05-22},
  abstract = {Today, Codenvy, Microsoft and Red Hat, Inc. announced adoption of a language server protocol project representing a collaborative effort to provide a common way to integrate programming languages across code editors and integrated development environments (IDEs). Announced during DevNation 2016, this protocol extends developer flexibility and productivity by enabling a rich editing experience within a variety of tools for different programming languages.``Historically, most programming languages have only been optimized for a single tool. This has prevented developers from using the editors they know and love, and has limited opportunities for language providers to reach a wide audience,'' said Tyler Jewell, Codenvy CEO and Eclipse Che project lead. ``With a common protocol supported by Microsoft, Red Hat and Codenvy, developers can gain access to intelligence for any language within their favorite tools."The Language Server Protocol is an open source project that defines a JSON-based data exchange protocol for language servers, hosted on GitHub and licensed under the creative commons and MIT licenses. By promoting interoperability between editors and language servers, the protocol enables developers to access intelligent programming language assistants \textendash{} such as find by symbol, syntax analysis, code completion, go to definition, outlining and refactoring \textendash{} within their editor or IDE of choice.``We have defined the common language server protocol after integrating the OmniSharp for C\# and TypeScript servers into VS Code,'' said Erich Gamma, Microsoft Distinguished Engineer. ``Having done a language server integration twice, it became obvious that a common protocol is a win-win for both tool and language providers: in this way, any language provider can make their language support available so that it is easily consumable by any tool provider.''The Language Server Protocol collaboration enables: Developer flexibility and choice: Developers can access rich editing experiences across new programming languages, while continuing to use their preferred tools. Multiple operating systems: Programming language providers can support multiple tools across a variety of operating systems, maximizing their reach and relevance. Editor support: Microsoft Visual Studio Code and Eclipse Che, the next-generation Eclipse IDE, have added support for the protocol. Many programming languages: A number of programming language servers are available today, including JSON, C++, and Powershell, which are available in VS Code or VS Code extensions. In addition, more language servers are planned to support the protocol later this year, including C\# by the Omnisharp project, xText and R by Typefox, JavaFX by Ensime and CSS by Microsoft. Red Hat has open sourced a project working to provide the first standalone Java language server which it proposes to donate to the Eclipse Foundation. Open collaboration: Codenvy, Microsoft and Red Hat are committed to developing this protocol in collaboration with the open source community. Hosted on a public repository, anyone can submit feedback or contribute pull requests to enhance and refine the project. Language server registry: Language servers are published as part of a global registry, built by Codenvy as an Eclipse project and hosted by the Eclipse Foundation, to make language servers discoverable for any tool to consume.``We see a tremendous opportunity to improve the way software is created, especially in the cloud, and we are focused on bringing that innovation to our customers in a way they can more easily adopt. Developer choice is a key area for us and interoperability of programming languages and tools is an important part of Red Hat's developer strategy,'' said Harry Mower, senior director, Developer Programs, Red Hat.The language server protocol is available today. For more information, visit: Protocol Repository Visual Studio Code blog post Videos of Eclipse Che FAQConnect with Red Hat Learn more about Red Hat Get more news in the Red Hat newsroom Read the Red Hat blog Follow Red Hat on Twitter Join Red Hat on Facebook Watch Red Hat videos on YouTube Join Red Hat on Google+ Follow Red Hat on LinkedIn},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/CIZXW5EM/red-hat-codenvy-and-microsoft-collaborate-language-server-protocol.html}
}

@misc{CodeSandbox,
  title = {{{CodeSandbox}}},
  journal = {CodeSandbox},
  url = {https://codesandbox.io/s/pensive-cerf-wof3l?file=/elm.json},
  urldate = {2021-12-25},
  abstract = {CodeSandbox is an online editor tailored for web applications.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/IVF6JM7G/pensive-cerf-wof3l.html}
}

@book{combemaleSoftwareLanguageEngineering2014,
  title = {Software {{Language Engineering}}: 7th {{International Conference}}, {{SLE}} 2014, {{V\"aster\aa s}}, {{Sweden}}, {{September}} 15-16, 2014. {{Proceedings}}},
  shorttitle = {Software {{Language Engineering}}},
  editor = {Combemale, Beno{\^i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
  year = {2014},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  volume = {8706},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-11245-9},
  url = {http://link.springer.com/10.1007/978-3-319-11245-9},
  urldate = {2022-02-20},
  isbn = {978-3-319-11244-2 978-3-319-11245-9},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/XKDSTILI/Combemale et al. - 2014 - Software Language Engineering 7th International C.pdf}
}

@misc{Configuration,
  title = {Configuration},
  journal = {webpack},
  url = {https://webpack.js.org/configuration/},
  urldate = {2022-01-02},
  abstract = {webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/7HBT22S2/configuration.html}
}

@misc{ConfigurationReferenceVue,
  title = {Configuration {{Reference}} | {{Vue CLI}}},
  url = {https://cli.vuejs.org/config/#vue-config-js},
  urldate = {2022-01-02},
  file = {/Users/ysander/Zotero/storage/SNBCT5MR/config.html}
}

@inproceedings{coulonModularDistributedIDE2020c,
  title = {Modular and Distributed {{IDE}}},
  booktitle = {Proceedings of the 13th {{ACM SIGPLAN International Conference}} on {{Software Language Engineering}}},
  author = {Coulon, Fabien and Auvolat, Alex and Combemale, Benoit and Bromberg, Y{\'e}rom-David and Ta{\"i}ani, Fran{\c c}ois and Barais, Olivier and Plouzeau, No{\"e}l},
  year = {2020},
  month = nov,
  pages = {270--282},
  publisher = {{ACM}},
  address = {{Virtual USA}},
  doi = {10.1145/3426425.3426947},
  url = {https://dl.acm.org/doi/10.1145/3426425.3426947},
  urldate = {2021-12-21},
  abstract = {Integrated Development Environments (IDEs) are indispensable companions to programming languages. They are increasingly turning towards Web-based infrastructure. The rise of a protocol such as the Language Server Protocol (LSP) that standardizes the separation between a languageagnostic IDE, and a language server that provides all language services (e.g., auto completion, compiler...) has allowed the emergence of high quality generic Web components to build the IDE part that runs in the browser. However, all language services require different computing capacities and response times to guarantee a user-friendly experience within the IDE. The monolithic distribution of all language services prevents to leverage on the available execution platforms (e.g., local platform, application server, cloud). In contrast with the current approaches that provide IDEs in the form of a monolithic client-server architecture, we explore in this paper the modularization of all language services to support their individual deployment and dynamic adaptation within an IDE. We evaluate the performance impact of the distribution of the language services across the available execution platforms on four EMF-based languages, and demonstrate the benefit of a custom distribution.},
  isbn = {978-1-4503-8176-5},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/Z6LUXX9T/Coulon et al. - 2020 - Modular and distributed IDE.pdf}
}

@misc{CUE,
  title = {{{CUE}}},
  journal = {CUE},
  url = {https://cuelang.org/},
  urldate = {2022-01-01},
  abstract = {Validate and define text-based and dynamic configuration},
  langid = {english},
  keywords = {rw},
  file = {/Users/ysander/Zotero/storage/9C3GEL7V/cuelang.org.html}
}

@inproceedings{dalmassoSurveyComparisonEvaluation2013,
  title = {Survey, Comparison and Evaluation of Cross Platform Mobile Application Development Tools},
  booktitle = {2013 9th {{International Wireless Communications}} and {{Mobile Computing Conference}} ({{IWCMC}})},
  author = {Dalmasso, Isabelle and Datta, Soumya Kanti and Bonnet, Christian and Nikaein, Navid},
  year = {2013},
  month = jul,
  pages = {323--328},
  issn = {2376-6506},
  doi = {10.1109/IWCMC.2013.6583580},
  abstract = {Mobile application development is becoming more challenging with diverse platforms and their software development kits. In order to reduce the cost of development and reach out to maximum users across several platforms, developers are migrating to cross platform application development tools. In this paper, we provide several decision criteria beyond the portability concerns for choosing suitable cross platform tool for application development. The desirable requirements in a cross platform framework are identified. A general architecture for cross platform application development is discussed. Then a survey of several write once run anywhere tools (PhoneGap, Titanium, Sencha Touch) are provided along with a classification and comparison among the tools. To examine the performance in terms of CPU, memory usage, power consumption, Android test applications are developed using such tools. It is found that PhoneGap consumes less memory, CPU and power since it does not included dedicated UI components. Finally the paper summarizes the contributions and concludes with some future directions.},
  keywords = {Android,Cascading style sheets,cross platform tools,Documentation,HTML,Mobile communication,mobile development,PhoneGap,Power demand,Smart phones,Titanium},
  file = {/Users/ysander/Zotero/storage/5AGAHT6N/Dalmasso et al. - 2013 - Survey, comparison and evaluation of cross platfor.pdf;/Users/ysander/Zotero/storage/XMPHGGE8/6583580.html}
}

@misc{DebugAdapters,
  title = {Debug {{Adapter Protocol}}},
  journal = {Official page for Debug Adapter Protocol},
  url = {https://microsoft.github.io/debug-adapter-protocol/implementors/adapters/},
  urldate = {2022-03-03},
  file = {/Users/ysander/Zotero/storage/5PCEXNC6/adapters.html}
}

@inproceedings{dejongeCosteffectiveMaintenanceTools2001,
  title = {Cost-Effective Maintenance Tools for Proprietary Languages},
  booktitle = {Proceedings {{IEEE International Conference}} on {{Software Maintenance}}. {{ICSM}} 2001},
  author = {{de Jonge}, M. and Monajemi, R.},
  year = {2001},
  month = nov,
  pages = {240--249},
  issn = {1063-6773},
  doi = {10.1109/ICSM.2001.972737},
  abstract = {Maintenance of proprietary languages and corresponding tooling is expensive. Postponing maintenance to reduce these costs is an often applied, short-term solution which eventually may lead to an unoperational toolset. The paper describes a case study carried out in cooperation with Lucent Technologies where maintenance cost is decreased by simplifying the development process of languages and tools. The development process is simplified by using a language-centered software engineering approach which increases software reuse and language dependent code generation. The case study was concerned with Lucent's proprietary SDL dialect and involved the re-engineering of an SDL grammar and the construction of an SDL documentation generator.},
  keywords = {Computer industry,Computer languages,Construction industry,Costs,Documentation,Software engineering,Software maintenance,Software standards,Software tools,Standards development},
  file = {/Users/ysander/Zotero/storage/VTUGFZI4/de Jonge and Monajemi - 2001 - Cost-effective maintenance tools for proprietary l.pdf;/Users/ysander/Zotero/storage/AK4W6E98/972737.html}
}

@article{desrivieresEclipsePlatformIntegrating2004,
  title = {Eclipse: {{A}} Platform for Integrating Development Tools. {{IBM Systems Journal}}, 43(2), 371-383},
  shorttitle = {Eclipse},
  author = {{des Rivieres}, Jim and Wiegand, J.},
  year = {2004},
  month = jan,
  journal = {IBM Systems Journal},
  volume = {43},
  pages = {371--383},
  doi = {10.1147/sj.432.0371},
  abstract = {Modern n-tier applications are developed using components implemented in many different technologies, including HTML, Java\texttrademark, JavaServer Pages\texttrademark{} (JSP\texttrademark ), Enterprise JavaBeans\texttrademark, connectors, COBOL or PL/1 programs, and relational database schemas. Creating an effective integrated development environment (IDE) for use in programming these applications presents some special challenges because a large number of different tool technologies have to be tightly integrated in support of development task flows. In order to meet these challenges, the Eclipse Platform was designed to serve as the common basis for diverse IDE-based products, providing open APIs (application programming interfaces) to facilitate this integration. This paper describes the overall architecture of the Eclipse Platform and the www.eclipse.org open source organization and consortium created to facilitate broad industry adoption of this platform.}
}

@misc{DhallConfigurationLanguage,
  title = {The {{Dhall}} Configuration Language},
  url = {https://dhall-lang.org/},
  urldate = {2022-01-01}
}

@article{dolstraNixSafePolicyFree2004,
  title = {Nix: {{A Safe}} and {{Policy-Free System}} for {{Software Deployment}}},
  author = {Dolstra, Eelco and {de Jonge}, Merijn and Visser, Eelco},
  year = {2004},
  pages = {14},
  abstract = {Existing systems for software deployment are neither safe nor sufficiently flexible. Primary safety issues are the inability to enforce reliable specification of component dependencies, and the lack of support for multiple versions or variants of a component. This renders deployment operations such as upgrading or deleting components dangerous and unpredictable. A deployment system must also be flexible (i.e., policy-free) enough to support both centralised and local package management, and to allow a variety of mechanisms for transferring components. In this paper we present Nix, a deployment system that addresses these issues through a simple technique of using cryptographic hashes to compute unique paths for component instances.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/TSISEHXN/Dolstra et al. - 2004 - Nix A Safe and Policy-Free System for Software De.pdf}
}

@phdthesis{dolstraPurelyFunctionalSoftware2006,
  title = {The Purely Functional Software Deployment Model},
  author = {Dolstra, Eelco},
  year = {2006},
  address = {{S.l.}},
  isbn = {9789039341308},
  langid = {english},
  school = {[s.n.]},
  annotation = {OCLC: 71702886},
  file = {/Users/ysander/Zotero/storage/W9GNXV8W/Dolstra - 2006 - The purely functional software deployment model.pdf}
}

@article{dosreisPrincipledCompleteEfficient2011,
  title = {A {{Principled}}, {{Complete}}, and {{Efficient Representation}} of {{C}}++},
  author = {Dos Reis, Gabriel and Stroustrup, Bjarne},
  year = {2011},
  month = sep,
  journal = {Mathematics in Computer Science},
  volume = {5},
  number = {3},
  pages = {335--356},
  issn = {1661-8270, 1661-8289},
  doi = {10.1007/s11786-011-0094-1},
  url = {http://link.springer.com/10.1007/s11786-011-0094-1},
  urldate = {2021-08-16},
  abstract = {We present a systematic representation of C++, called IPR, for complete semantic analysis and semantics-based program transformations. We describe the ideas and design principles that shaped the IPR. In particular, we describe how general type-based unification is key to minimal compact representation, fast type-safe traversal, and scalability. For example, the representation of a fairly typical non-trivial C++ program in GCC 3.4.2 was 32 times larger than its IPR representation; this led to significant improvements to GCC. IPR is general enough to handle real-world programs involving many translation units, archaic programming styles, and generic programming using C++0x extensions that affect the type system. The difficult issue of how to represent irregular (ad hoc) features in a systematic (non ad hoc) manner is among the key contributions of this paper. The IPR data structure can represent all of C++ with just 157 simple node types; to compare the ISO C++ grammar has over 700 productions. The IPR is used for a variety of program analysis and transformation tasks, such as visualization, loop simplification, and concept extraction. Finally, we report impacts of this work on existing C++ compilers.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/GD5BCKAX/Dos Reis and Stroustrup - 2011 - A Principled, Complete, and Efficient Representati.pdf}
}

@incollection{duarteRetrofittingTypestatesRust2021,
  title = {Retrofitting {{Typestates}} into {{Rust}}},
  booktitle = {25th {{Brazilian Symposium}} on {{Programming Languages}}},
  author = {Duarte, Jos{\'e} and Ravara, Ant{\'o}nio},
  year = {2021},
  month = sep,
  pages = {83--91},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  url = {https://doi.org/10.1145/3475061.3475082},
  urldate = {2022-01-09},
  abstract = {As software permeates our lives, bugs become increasingly expensive; the best way to reduce their cost is to reduce the number of bugs. Of course, this is easier said than done and, at best, we can go after their root causes to mitigate them. One of such causes is state, whether it is the state of a light bulb (i.e. on/off), or the state of a complex protocol, reasoning about state is a complex process which developers are required to do with subpar tools. Ideally, we want to specify constraints and have the computer reason for us; typestates enable developers to describe states using the type system and allow the compiler to reason about them. We propose an approach to bring typestates to Rust, without any external tools, leveraging only Rust's type and macro systems. Our approach provides a macro-based domain-specific language which enables developers to easily express and implement typestates, along with certain state machine safety guarantees, it is open-source and available at https://github.com/rustype/typestate-rs.},
  isbn = {978-1-4503-9062-0},
  keywords = {Behavioral Typing,Domain-specific Languages,Macros,Protocol Compliance,Rust,Session Types,Typestates},
  file = {/Users/ysander/Zotero/storage/V9VQI2W5/Duarte and Ravara - 2021 - Retrofitting Typestates into Rust.pdf}
}

@misc{EclipseCheKubernetesNative,
  title = {Eclipse {{Che}} | {{The Kubernetes-Native IDE}} for {{Developer Teams}}},
  url = {https://www.eclipse.org/che/},
  urldate = {2021-12-21},
  file = {/Users/ysander/Zotero/storage/NEDSPG5F/che.html}
}

@misc{EclipseFP,
  title = {{{EclipseFP The Haskell}} Plug-in for {{Eclipse}}},
  author = {Moresmau},
  url = {https://eclipsefp.github.io/index.html},
  urldate = {2022-05-01},
  file = {/Users/ysander/Zotero/storage/HHFUMAGP/index.html}
}

@article{ellisWriteExecuteAssess,
  title = {Write, {{Execute}}, {{Assess}}: {{Program Synthesis}} with a {{REPL}}},
  author = {Ellis, Kevin and Nye, Maxwell and Pu, Yewen and Sosa, Felix and Tenenbaum, Josh and {Solar-Lezama}, Armando},
  pages = {10},
  abstract = {We present a neural program synthesis approach integrating components which write, execute, and assess code to navigate the search space of possible programs. We equip the search process with an interpreter or a read-eval-print-loop (REPL), which immediately executes partially written programs, exposing their semantics. The REPL addresses a basic challenge of program synthesis: tiny changes in syntax can lead to huge changes in semantics. We train a pair of models, a policy that proposes the new piece of code to write, and a value function that assesses the prospects of the code written so-far. At test time we can combine these models with a Sequential Monte Carlo algorithm. We apply our approach to two domains: synthesizing text editing programs and inferring 2D and 3D graphics programs.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/3E4QL6TK/Ellis et al. - Write, Execute, Assess Program Synthesis with a R.pdf}
}

@misc{ExoticallySizedTypes,
  title = {Exotically {{Sized Types}} - {{The Rustonomicon}}},
  url = {https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts},
  urldate = {2022-03-26},
  file = {/Users/ysander/Zotero/storage/RDR6ATL6/exotic-sizes.html}
}

@article{farshidiDecisionModelProgramming2021,
  title = {A Decision Model for Programming Language Ecosystem Selection: {{Seven}} Industry Case Studies},
  shorttitle = {A Decision Model for Programming Language Ecosystem Selection},
  author = {Farshidi, Siamak and Jansen, Slinger and Deldar, Mahdi},
  year = {2021},
  month = nov,
  journal = {Information and Software Technology},
  volume = {139},
  pages = {106640},
  issn = {0950-5849},
  doi = {10.1016/j.infsof.2021.106640},
  url = {https://www.sciencedirect.com/science/article/pii/S0950584921001051},
  urldate = {2021-12-21},
  abstract = {Context: Software development is a continuous decision-making process that mainly relies on the software engineer's experience and intuition. One of the essential decisions in the early stages of the process is selecting the best fitting programming language ecosystem based on the project requirements. A significant number of criteria, such as developer availability and consistent documentation, in addition to the number of available options in the market, lead to a challenging decision-making process. As the selection of programming language ecosystems depends on the application to be developed and its environment, a decision model is required to analyze the selection problem using systematic identification and evaluation of potential alternatives for a development project. Method: Recently, we introduced a framework to build decision models for technology selection problems in software production. Furthermore, we designed and implemented a decision support system that uses such decision models to support software engineers with their decision-making problems. This study presents a decision model based on the framework for the programming language ecosystem selection problem. Results: The decision model has been evaluated through seven real-world case studies at seven software development companies. The case study participants declared that the approach provides significantly more insight into the programming language ecosystem selection process and decreases the decision-making process's time and cost. Conclusion: With the decision model, software engineers can more rapidly evaluate and select programming language ecosystems. Having the knowledge in the decision model readily available supports software engineers in making more efficient and effective decisions that meet their requirements and priorities. Furthermore, such reusable knowledge can be employed by other researchers to develop new concepts and solutions for future challenges.},
  langid = {english},
  keywords = {Decision model,Decision support system,Industry case study,Multi-criteria decision-making,Programming language ecosystem selection,Software production},
  file = {/Users/ysander/Zotero/storage/SRNKLTUD/Farshidi et al. - 2021 - A decision model for programming language ecosyste.pdf}
}

@inproceedings{findlerContractsHigherorderFunctions2002,
  title = {Contracts for Higher-Order Functions},
  booktitle = {Proceedings of the Seventh {{ACM SIGPLAN}} International Conference on {{Functional}} Programming},
  author = {Findler, Robert Bruce and Felleisen, Matthias},
  year = {2002},
  month = sep,
  series = {{{ICFP}} '02},
  pages = {48--59},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/581478.581484},
  url = {https://doi.org/10.1145/581478.581484},
  urldate = {2022-02-06},
  abstract = {Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the "Design by Contract" philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.In contrast, languages with higher-order functions do not support assertion-based contracts. Because predicates on functions are, in general, undecidable, specifying such predicates appears to be meaningless. Instead, the functional languages community developed type systems that statically approximate interesting predicates.In this paper, we show how to support higher-order function contracts in a theoretically well-founded and practically viable manner. Specifically, we introduce {$\lambda$}con, a typed lambda calculus with assertions for higher-order functions. The calculus models the assertion monitoring system that we employ in DrScheme. We establish basic properties of the model (type soundness, etc.) and illustrate the usefulness of contract checking with examples from DrScheme's code base.We believe that the development of an assertion system for higher-order functions serves two purposes. On one hand, the system has strong practical potential because existing type systems simply cannot express many assertions that programmers would like to state. On the other hand, an inspection of a large base of invariants may provide inspiration for the direction of practical future type system research.},
  isbn = {978-1-58113-487-2},
  keywords = {behavioral specifications,contracts,higher-order functions,predicate typing,solfware reliability},
  file = {/Users/ysander/Zotero/storage/RZRXGHDM/Findler and Felleisen - 2002 - Contracts for higher-order functions.pdf}
}

@incollection{findlerContractsPairsProjections2006,
  title = {Contracts as {{Pairs}} of {{Projections}}},
  booktitle = {Functional and {{Logic Programming}}},
  author = {Findler, Robert Bruce and Blume, Matthias},
  editor = {Hagiya, Masami and Wadler, Philip},
  year = {2006},
  volume = {3945},
  pages = {226--241},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/11737414_16},
  url = {http://link.springer.com/10.1007/11737414_16},
  urldate = {2022-02-06},
  abstract = {Assertion-based contracts provide a powerful mechanism for stating invariants at module boundaries and for enforcing them uniformly. In 2002, Findler and Felleisen showed how to add contracts to higher-order functional languages, allowing programmers to assert invariants about functions as values. Following up in 2004, Blume and McAllester provided a quotient model for contracts. Roughly speaking, their model equates a contract with the set of values that cannot violate the contract. Their studies raised interesting questions about the nature of contracts and, in particular, the nature of the any contract.},
  isbn = {978-3-540-33438-5 978-3-540-33439-2},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/XP9XERUB/Findler and Blume - 2006 - Contracts as Pairs of Projections.pdf}
}

@article{findlerICFP2002Contracts2013a,
  title = {{{ICFP}} 2002: {{Contracts}} for Higher-Order Functions},
  shorttitle = {{{ICFP}} 2002},
  author = {Findler, Robert Bruce and Felleisen, Matthias},
  year = {2013},
  month = jul,
  journal = {ACM SIGPLAN Notices},
  volume = {48},
  number = {4S},
  pages = {34--45},
  issn = {0362-1340, 1558-1160},
  doi = {10.1145/2502508.2502521},
  url = {https://dl.acm.org/doi/10.1145/2502508.2502521},
  urldate = {2022-02-06},
  abstract = {Assertions play an important role in the construction of robust software. Their use in programming languages dates back to the 1970s. Eiffel, an object-oriented programming language, wholeheartedly adopted assertions and developed the ``Design by Contract'' philosophy. Indeed, the entire object-oriented community recognizes the value of assertion-based contracts on methods.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/VRX9JSEF/Findler and Felleisen - 2013 - ICFP 2002 Contracts for higher-order functions.pdf}
}

@article{fluriChangeDistillingTree2007,
  title = {Change {{Distilling}}:{{Tree Differencing}} for {{Fine-Grained Source Code Change Extraction}}},
  shorttitle = {Change {{Distilling}}},
  author = {Fluri, Beat and Wursch, Michael and PInzger, Martin and Gall, Harald},
  year = {2007},
  month = nov,
  journal = {IEEE Transactions on Software Engineering},
  volume = {33},
  number = {11},
  pages = {725--743},
  issn = {0098-5589, 1939-3520, 2326-3881},
  doi = {10.1109/TSE.2007.70731},
  url = {https://ieeexplore.ieee.org/document/4339230/},
  urldate = {2021-08-31},
  abstract = {A key issue in software evolution analysis is the identification of particular changes that occur across several versions of a program. We present change distilling, a tree differencing algorithm for fine-grained source code change extraction. For that, we have improved the existing algorithm by Chawathe et al. for extracting changes in hierarchically structured data [8]. Our algorithm extracts changes by finding both a match between the nodes of the compared two abstract syntax trees and a minimum edit script that can transform one tree into the other given the computed matching. As a result, we can identify fine-grained change types between program versions according to our taxonomy of source code changes. We evaluated our change distilling algorithm with a benchmark that we developed, which consists of 1,064 manually classified changes in 219 revisions of eight methods from three different open source projects. We achieved significant improvements in extracting types of source code changes: Our algorithm approximates the minimum edit script 45 percent better than the original change extraction approach by Chawathe et al. We are able to find all occurring changes and almost reach the minimum conforming edit script, that is, we reach a mean absolute percentage error of 34 percent, compared to the 79 percent reached by the original algorithm. The paper describes both our change distilling algorithm and the results of our evaluation.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/F827A9BC/Fluri et al. - 2007 - Change DistillingTree Differencing for Fine-Grain.pdf}
}

@article{frenzelExperienceReportBuilding2007,
  title = {Experience Report: Building an Eclipse-Based {{IDE}} for {{Haskell}}},
  shorttitle = {Experience Report},
  author = {Frenzel, Leif},
  year = {2007},
  month = oct,
  journal = {ACM SIGPLAN Notices},
  volume = {42},
  number = {9},
  pages = {220--222},
  issn = {0362-1340},
  doi = {10.1145/1291220.1291186},
  url = {https://doi.org/10.1145/1291220.1291186},
  urldate = {2022-02-19},
  abstract = {This paper summarizes experiences from an open source project that builds a free Haskell IDE based on Eclipse (an open source IDE platform). Eclipse is extensible and has proved to be a good basis for IDEs for several programming languages. Difficulties arise mainly because it is written in Java and requires extensions to be written in Java. This made it hard to reuse existing development tools implemented in Haskell, and turned out to be a considerable obstacle to finding contributors. Several approaches to resolve these issues are described and their advantages and disadvantages discussed.},
  file = {/Users/ysander/Zotero/storage/68IZJ66I/Frenzel - 2007 - Experience report building an eclipse-based IDE f.pdf}
}

@article{gagnauxDevelopingMinimalLanguage,
  title = {Developing a {{Minimal Language Server}} for the {{Frege Programming Language}}: An {{Experience Report}}},
  author = {Gagnaux, Thibault and Konig, Dierk},
  pages = {7},
  abstract = {Language servers provide features such as code completion and documentation on hover to text editors and integrated developer environments. These features help developers to write software more efficiently but take a significant time to build. The language server protocol addresses this problem by allowing to write a language server once and reuse it with many popular text editors. In this experience report, I present the steps needed to develop a minimal language server for the Frege programming language communicating with a Visual Studio Code plugin over the language server protocol. I start with Microsoft's example language server and gradually extend it. Firstly, I port the example server from Typescript to Java and secondly, I integrate the Frege compiler to show compiler errors and type signatures on hover. This experience report should help others to estimate the work of developing a language server and how to approach this task.},
  langid = {english},
  keywords = {rw},
  file = {/Users/ysander/Zotero/storage/YAPE252T/Gagnaux and Konig - Developing a Minimal Language Server for the Frege.pdf}
}

@misc{GollumGitbasedWiki2022,
  title = {Gollum -- {{A}} Git-Based {{Wiki}}},
  year = {2022},
  month = jan,
  url = {https://github.com/gollum/gollum},
  urldate = {2022-01-04},
  abstract = {A simple, Git-powered wiki with a sweet API and local frontend.},
  copyright = {MIT},
  howpublished = {gollum},
  keywords = {documentation-tool,gollum,jruby-support,wiki}
}

@misc{guindonReleaseEclipseIDE,
  title = {Release - {{Eclipse IDE}} | {{The Eclipse Foundation}}},
  author = {Guindon, Christopher},
  journal = {eclipseide.org},
  url = {https://eclipseide.org/release/},
  urldate = {2022-05-01},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/LN8Z83N9/release.html}
}

@misc{HaskellMacIDE,
  title = {Haskell for {{Mac IDE}} \textemdash{} {{Learn Functional Programming}} with {{Haskell}}},
  url = {http://haskellformac.com/},
  urldate = {2021-12-28},
  file = {/Users/ysander/Zotero/storage/AK5PYMPV/haskellformac.com.html}
}

@misc{HaskForceHaskellPlugin,
  title = {{{HaskForce}} - {{The Haskell}} Plugin for {{IntelliJ IDEA}}},
  url = {https://haskforce.com/},
  urldate = {2022-02-19},
  file = {/Users/ysander/Zotero/storage/F4USGFHV/haskforce.com.html}
}

@phdthesis{hessDafnyLanguageServer2019,
  type = {Srp},
  title = {Dafny {{Language Server Redesign}}},
  author = {Hess, Marcel and Kistler, Thomas},
  year = {2019},
  month = dec,
  url = {https://eprints.ost.ch/id/eprint/842/},
  urldate = {2022-02-18},
  abstract = {Dafny is a formal programming language to proof a program's correctness with preconditions, postconditions, loop invariants and loop variants. In a previous bachelor thesis, a plugin for Visual Studio Code was created to support Dafny. Developers can profit by several features from this plugin. For example, if Dafny cannot prove a postcondition, the code will be highlighted and a counter example can be shown. Other features include code compilation, auto completion suggestions and various refactoring tools. The plugin communicates with a language server. This interface was realized with the language server protocol. This protocol is a specification which allows an easy communication between an IDE and a language server. The language server itself was using an additional JSON-interface to request information from the actual Dafny library. The goal of this thesis was to rewrite the language server and directly integrate it into the Dafny library to save one of the communication paths. In order to simplify the development of further features, the tighter integration was inevitable. Instead of making complex adjustments to the server API, one can just use the language server protocol standard to increase functionality. For this, the new language server had to be rewritten from TypeScript to C\#.  The old language server could be completely superseded by our new, rewritten server in C\#. Since we are using the same project solution as the Dafny library, Dafny's methods and classes are directly accessible. That means, that the interface from the old language server to the Dafny library is now obsolete. Most features of the previous bachelor thesis are supported with the new language server. These include code verification, error highlighting, making suggestions for auto completion, code lens, go to definition, compilation, as well as syntax highlighting. Since the language server is integrated with the Dafny library, new features can be added in a convenient way.},
  collaborator = {Corbat, Thomas},
  langid = {english},
  school = {HSR Hochschule f\"ur Technik Rapperswil},
  file = {/Users/ysander/Zotero/storage/P7W7JCWF/Hess and Kistler - 2019 - Dafny Language Server Redesign.pdf;/Users/ysander/Zotero/storage/5GKIRTGL/842.html}
}

@misc{HighlightsUnit422021,
  title = {Highlights {{From}} the {{Unit}} 42 {{Cloud Threat Report}}, {{2H}} 2021},
  year = {2021},
  month = sep,
  journal = {Unit42},
  url = {https://unit42.paloaltonetworks.com/cloud-threat-report-2h-2021/},
  urldate = {2022-01-04},
  abstract = {The Unit 42 Cloud Threat Report, 2H 2021, covers supply chain attacks in the cloud and provides actionable recommendations to help prevent them.},
  langid = {american},
  file = {/Users/ysander/Zotero/storage/PM326PTS/cloud-threat-report-2h-2021.html}
}

@book{hintjensZeroMQMessagingMany2013,
  title = {{{ZeroMQ}}: {{Messaging}} for {{Many Applications}}},
  shorttitle = {{{ZeroMQ}}},
  author = {Hintjens, Pieter},
  year = {2013},
  month = mar,
  publisher = {{"O'Reilly Media, Inc."}},
  abstract = {Dive into \O MQ (aka ZeroMQ), the smart socket library that gives you fast, easy, message-based concurrency for your applications. With this quick-paced guide, you'll learn hands-on how to use this scalable, lightweight, and highly flexible networking tool for exchanging messages among clusters, the cloud, and other multi-system environments.\O MQ maintainer Pieter Hintjens takes you on a tour of real-world applications, using extended examples in C to help you work with \O MQ's API, sockets, and patterns. Learn how to use specific \O MQ programming techniques, build multithreaded applications, and create your own messaging architectures. You'll discover how \O MQ works with several programming languages and most operating systems\textemdash with little or no cost.Learn \O MQ's main patterns: request-reply, publish-subscribe, and pipelineWork with \O MQ sockets and patterns by building several small applicationsExplore advanced uses of \O MQ's request-reply pattern through working examplesBuild reliable request-reply patterns that keep working when code or hardware failsExtend \O MQ's core pub-sub patterns for performance, reliability, state distribution, and monitoringLearn techniques for building a distributed architecture with \O MQDiscover what's required to build a general-purpose framework for distributed applications},
  googlebooks = {KWtT5CJc6FYC},
  isbn = {978-1-4493-3406-2},
  langid = {english},
  keywords = {Computers / Internet / Web Services \& APIs,Computers / Languages / C}
}

@misc{HowWriteGreat,
  title = {How to Write a Great Research Paper},
  journal = {Microsoft Research},
  url = {https://www.microsoft.com/en-us/research/academic-program/write-great-research-paper/},
  urldate = {2021-11-24},
  abstract = {This talk offers seven simple, concrete suggestions for how to improve your research papers. You may also find my talks on how to write a great research proposal and how to give a great research talk useful.},
  langid = {american},
  file = {/Users/ysander/Zotero/storage/BH5M3R38/write-great-research-paper.html}
}

@misc{IDECodeReifying,
  title = {{{IDE}} as {{Code}}: {{Reifying Language Protocols}} as {{First-Class Citizens}} | 14th {{Innovations}} in {{Software Engineering Conference}} (Formerly Known as {{India Software Engineering Conference}})},
  url = {https://dl.acm.org/doi/abs/10.1145/3452383.3452406?casa_token=v3kB1B5yot4AAAAA:Jyslsfa9urSl9RdEgHwSIBID7HFDmXz6ocP-RMMjIKw6gwVXJsjQ7Z6awwbNP8Vm2loot6jeRsSL},
  urldate = {2022-03-03},
  file = {/Users/ysander/Zotero/storage/DKZHCFGH/3452383.html}
}

@misc{incCommunityOpenInnovation,
  title = {The {{Community}} for {{Open Innovation}} and {{Collaboration}} | {{The Eclipse Foundation}}},
  author = {Inc, Eclipse Foundation},
  url = {https://www.eclipse.org/},
  urldate = {2022-05-01},
  abstract = {The Eclipse Foundation - home to a global community, the Eclipse IDE, Jakarta EE and over 415 open source projects, including runtimes, tools and frameworks.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/NIJUJ6SW/www.eclipse.org.html}
}

@misc{IncrementalAnalysisReal,
  title = {Incremental Analysis of Real Programming Languages | {{Proceedings}} of the {{ACM SIGPLAN}} 1997 Conference on {{Programming}} Language Design and Implementation},
  url = {https://dl.acm.org/doi/10.1145/258915.258920},
  urldate = {2021-11-12},
  file = {/Users/ysander/Zotero/storage/XKEVSWVU/Wagner and Graham - 2000 - Incremental Analysis of Real Programming Languages.pdf}
}

@misc{IntegratingAWSCloudFormation2020,
  title = {Integrating {{AWS CloudFormation}} Security Tests with {{AWS Security Hub}} and {{AWS CodeBuild}} Reports},
  year = {2020},
  month = sep,
  journal = {Amazon Web Services},
  url = {https://aws.amazon.com/blogs/security/integrating-aws-cloudformation-security-tests-with-aws-security-hub-and-aws-codebuild-reports/},
  urldate = {2022-01-04},
  abstract = {The concept of infrastructure as code, by using pipelines for continuous integration and delivery, is fundamental for the development of cloud infrastructure. Including code quality and vulnerability scans in the pipeline is essential for the security of this infrastructure as code. In one of our previous posts, How to build a CI/CD pipeline for container [\ldots ]},
  chapter = {Advanced (300)},
  langid = {american},
  file = {/Users/ysander/Zotero/storage/HLRLPX9V/integrating-aws-cloudformation-security-tests-with-aws-security-hub-and-aws-codebuild-reports.html}
}

@misc{IntelliJHaskellIntelliJIDEs,
  title = {{{IntelliJ-Haskell}} - {{IntelliJ IDEs Plugin}} | {{Marketplace}}},
  journal = {JetBrains Marketplace},
  url = {https://plugins.jetbrains.com/plugin/8258-intellij-haskell},
  urldate = {2022-05-01},
  abstract = {Haskell language support.},
  file = {/Users/ysander/Zotero/storage/4AS55KVT/8258-intellij-haskell.html}
}

@misc{IntelliJIDEACapable,
  title = {{{IntelliJ IDEA}}: {{The Capable}} \& {{Ergonomic Java IDE}} by {{JetBrains}}},
  shorttitle = {{{IntelliJ IDEA}}},
  journal = {JetBrains},
  url = {https://www.jetbrains.com/idea/},
  urldate = {2022-05-01},
  abstract = {A Capable and Ergonomic Java IDE for Enterprise Java, Scala, Kotlin and much more...},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/5FMAVJRN/idea.html}
}

@article{iungSystematicMappingStudy2020,
  title = {Systematic Mapping Study on Domain-Specific Language Development Tools},
  author = {Iung, An{\'i}bal and Carbonell, Jo{\~a}o and Marchezan, Luciano and Rodrigues, Elder and Bernardino, Maicon and Basso, Fabio Paulo and Medeiros, Bruno},
  year = {2020},
  month = sep,
  journal = {Empirical Software Engineering},
  volume = {25},
  number = {5},
  pages = {4205--4249},
  issn = {1382-3256, 1573-7616},
  doi = {10.1007/s10664-020-09872-1},
  url = {https://link.springer.com/10.1007/s10664-020-09872-1},
  urldate = {2021-12-15},
  abstract = {Domain-specific languages (DSL) are programming or modeling languages devoted to a given application domain. There are many tools used to support the implementation of a DSL, making hard the decision-making process for one or another. In this sense, identifying and mapping their features is relevant for decision-making by academic and industrial initiative on DSL development. Objective: The goal of this work is to identify and map the tools, Language Workbenches (LW), or frameworks that were proposed to develop DSLs discussed and referenced in publications between 2012 and 2019. Method: A Systematic Mapping Study (SMS) of the literature scoping tools for DSL development. Results: We identified 59 tools, including 9 under a commercial license and 41 with non-commercial licenses, and analyzed their features from 230 papers. Conclusion: There is a substantial amount of tools that cover a large number of features. Furthermore, we observed that usually, the developer adopts one type of notation to implement the DSL: textual or graphical. We also discuss research gaps, such as a lack of tools that allow meta-meta model transformations and that support modeling tools interoperability.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/YJRILR6I/Iung et al. - 2020 - Systematic mapping study on domain-specific langua.pdf}
}

@inproceedings{jeanjeanIDECodeReifying2021,
  title = {{{IDE}} as {{Code}}: {{Reifying Language Protocols}} as {{First-Class Citizens}}},
  shorttitle = {{{IDE}} as {{Code}}},
  booktitle = {14th {{Innovations}} in {{Software Engineering Conference}} (Formerly Known as {{India Software Engineering Conference}})},
  author = {Jeanjean, Pierre and Combemale, Benoit and Barais, Olivier},
  year = {2021},
  month = feb,
  pages = {1--5},
  publisher = {{ACM}},
  address = {{Bhubaneswar, Odisha India}},
  doi = {10.1145/3452383.3452406},
  url = {https://dl.acm.org/doi/10.1145/3452383.3452406},
  urldate = {2022-03-03},
  abstract = {To cope with the ever-growing number of programming languages, manufacturers of Integrated Development Environments (IDE) have recently defined protocols as a way to use and share multiple language services (e.g., auto-completion, type checker, language runtime) in language-agnostic environments (i.e., the user interface provided by the IDE): the most notable are the Language Server Protocol (LSP) for textual editors, and the Debug Adapter Protocol (DAP) for debugging facilities. These protocols rely on a proper specification of the services that are commonly found in the tool support of general-purpose languages, and define a fixed set of capabilities to offer in the IDE. However, new languages appear regularly offering unique constructs (e.g., Domain-Specific Languages), and supported by dedicated services to be offered as new capabilities in IDEs. This trend leads to the multiplication of new protocols, hard to combine and possibly incompatible (e.g., overlap, different technological stacks). Beyond the proposition of specific protocols, the goal of this paper is to stress out the importance of being able to specify language protocols and to offer IDEs to be configured with such protocol specifications. We present our vision by discussing the main concepts for the specification of language protocols, and an approach that can make use of these specifications in order to deploy an IDE as a set of coordinated, individually deployed, language capabilities (e.g., microservice choreography). IDEs went from directly supporting languages to protocols, and we envision in this paper the next step: IDE as Code, where language protocols are created or inferred on demand and serve as support of an adaptation loop taking in charge of the (re)configuration of the IDE.},
  isbn = {978-1-4503-9046-0},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/E5J2IGSH/Jeanjean et al. - 2021 - IDE as Code Reifying Language Protocols as First-.pdf}
}

@article{jenkinsConcerningInterruptions2006,
  title = {Concerning {{Interruptions}}},
  author = {Jenkins, Stephen},
  year = {2006},
  month = nov,
  journal = {Computer},
  volume = {39},
  number = {11},
  pages = {116--115},
  issn = {1558-0814},
  doi = {10.1109/MC.2006.378},
  abstract = {Peak productivity depends on dealing with interruptions effectively.},
  keywords = {Computing profession,Electronic mail,Frequency,HTML,Information filtering,Information filters,Optimized production technology,Productivity,Telephony,Voice mail,Web server},
  file = {/Users/ysander/Zotero/storage/YYM6ZS76/Jenkins - 2006 - Concerning Interruptions.pdf;/Users/ysander/Zotero/storage/G2HGJA67/4014785.html}
}

@article{jonesHowWriteGreat,
  title = {How to Write a Great Research Paper {{Seven}} Simple Suggestions},
  author = {Jones, Simon Peyton},
  pages = {52},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/KWQKMIU4/Jones - How to write a great research paper Seven simple s.pdf}
}

@misc{JSON,
  title = {{{JSON}}},
  url = {https://www.json.org/json-en.html},
  urldate = {2022-01-01},
  file = {/Users/ysander/Zotero/storage/FY6F8PQD/json-en.html}
}

@misc{JsonnetDataTemplating,
  title = {Jsonnet - {{The Data Templating Language}}},
  url = {https://jsonnet.org/},
  urldate = {2022-01-01},
  file = {/Users/ysander/Zotero/storage/4L7VGS5Q/jsonnet.org.html}
}

@misc{JSONRPCSpecification,
  title = {{{JSON-RPC}} 2.0 {{Specification}}},
  url = {https://www.jsonrpc.org/specification},
  urldate = {2021-12-15},
  file = {/Users/ysander/Zotero/storage/XB4PL6I9/specification.html}
}

@misc{JSONSchema,
  title = {{{JSON Schema}}},
  journal = {JSON Schema},
  url = {https://json-schema.org/},
  urldate = {2022-01-02},
  abstract = {The home of JSON Schema},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/7T7MQF4H/json-schema.org.html}
}

@inproceedings{justoProgrammingDistributedSystems1992,
  title = {Programming Distributed Systems with Configuration Languages},
  booktitle = {1992 {{International Workshop}} on {{Configurable Distributed Systems}}},
  author = {Justo, G.R.R. and Cunha, P.R.F.},
  year = {1992},
  month = may,
  pages = {118--127},
  abstract = {The importance of using languages to specify the structure of a system as a set of components and their interconnections separately from the functional description of the components has been widely recognised. These languages, sometimes called configuration languages, have a natural application in the description of the structural topology of concurrent and distributed systems. The design of these languages has focussed on developing simple declarative languages only for specification of the structure of the system. The authors present a different approach to configuration languages where they use them as a framework to exploit dynamic restructuring to give elegant and modular solutions to concurrent and distributed problems. They present the programming model CL, study its properties and give some examples. A run-time support for the implementation of the model is also presented.{$<>$}},
  keywords = {High-level languages,Parallel architectures,Parallel programming,Software requirements and specifications},
  file = {/Users/ysander/Zotero/storage/7PMYZVK7/Justo and Cunha - 1992 - Programming distributed systems with configuration.pdf}
}

@inproceedings{katsSpoofaxLanguageWorkbench2010,
  title = {The Spoofax Language Workbench: Rules for Declarative Specification of Languages and {{IDEs}}},
  shorttitle = {The Spoofax Language Workbench},
  booktitle = {Proceedings of the {{ACM}} International Conference on {{Object}} Oriented Programming Systems Languages and Applications},
  author = {Kats, Lennart C.L. and Visser, Eelco},
  year = {2010},
  month = oct,
  series = {{{OOPSLA}} '10},
  pages = {444--463},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/1869459.1869497},
  url = {https://doi.org/10.1145/1869459.1869497},
  urldate = {2021-12-21},
  abstract = {Spoofax is a language workbench for efficient, agile development of textual domain-specific languages with state-of-the-art IDE support. Spoofax integrates language processing techniques for parser generation, meta-programming, and IDE development into a single environment. It uses concise, declarative specifications for languages and IDE services. In this paper we describe the architecture of Spoofax and introduce idioms for high-level specifications of language semantics using rewrite rules, showing how analyses can be reused for transformations, code generation, and editor services such as error marking, reference resolving, and content completion. The implementation of these services is supported by language-parametric editor service classes that can be dynamically loaded by the Eclipse IDE, allowing new languages to be developed and used side-by-side in the same Eclipse environment.},
  isbn = {978-1-4503-0203-6},
  keywords = {domain-specific language,dsl,eclipse,IDE,language workbench,meta-tooling,sdf,sglr,spoofax,stratego},
  file = {/Users/ysander/Zotero/storage/8IGSZG4H/Kats and Visser - 2010 - The spoofax language workbench rules for declarat.pdf}
}

@inproceedings{keidelIDEPortabilityProblem2016,
  title = {The {{IDE}} Portability Problem and Its Solution in {{Monto}}},
  booktitle = {Proceedings of the 2016 {{ACM SIGPLAN International Conference}} on {{Software Language Engineering}}},
  author = {Keidel, Sven and Pfeiffer, Wulf and Erdweg, Sebastian},
  year = {2016},
  month = oct,
  series = {{{SLE}} 2016},
  pages = {152--162},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2997364.2997368},
  url = {https://doi.org/10.1145/2997364.2997368},
  urldate = {2021-12-21},
  abstract = {Modern IDEs support multiple programming languages via plug-ins, but developing a high-quality language plug-in is a huge development effort and individual plug-ins are not reusable in other IDEs. We call this the IDE portability problem. In this paper, we present a solution to the IDE portability problem based on a language-independent and IDE-independent intermediate representation (IR) for editor-service products. This IR enables IDE-independent language services to provide editor services for arbitrary IDEs, using language-independent IDE plug-ins. We combine the IR with a service-oriented architecture to facilitate the modular addition of language services, the decomposition of language services into smaller interdependent services, and the use of arbitrary implementation languages for services. To evaluate the feasibility of our design, we have implemented the IR and architecture in a framework called Monto. We demonstrate the generality of our design by constructing language services for Java, JavaScript, Python, and Haskell and show that they are reusable in the Eclipse IDE and in a web-based IDE. We also evaluate the performance of Monto and show that Monto is responsive and has admissible performance overhead.},
  isbn = {978-1-4503-4447-0},
  keywords = {integrated development environments,reusable software},
  file = {/Users/ysander/Zotero/storage/IYZKD6LF/Keidel et al. - 2016 - The IDE portability problem and its solution in Mo.pdf}
}

@article{korneckiExperimentalEvaluationSoftware2005,
  title = {Experimental Evaluation of Software Development Tools for Safety-Critical Real-Time Systems},
  author = {Kornecki, Andrew J. and Zalewski, Janusz},
  year = {2005},
  month = sep,
  journal = {Innovations in Systems and Software Engineering},
  volume = {1},
  number = {2},
  pages = {176--188},
  issn = {1614-5046, 1614-5054},
  doi = {10.1007/s11334-005-0013-1},
  url = {http://link.springer.com/10.1007/s11334-005-0013-1},
  urldate = {2021-11-08},
  abstract = {Since the early years of computing, programmers, systems analysts, and software engineers have sought ways to improve development process efficiency. Software development tools are programs that help developers create other programs and automate mundane operations while bringing the level of abstraction closer to the application engineer. In practice, software development tools have been in wide use among safety-critical system developers. Typical application areas include space, aviation, automotive, nuclear, railroad, medical, and military. While their use is widespread in safety-critical systems, the tools do not always assure the safe behavior of their respective products. This study examines the assumptions, practices, and criteria for assessing software development tools for building safety-critical real-time systems. Experiments were designed for an avionics testbed and conducted on six industry-strength tools to assess their functionality, usability, efficiency, and traceability. The results shed some light on possible improvements in the tool evaluation process that can lead to potential tool qualification for safety-critical real-time systems.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/8BBQ6DXZ/Kornecki and Zalewski - 2005 - Experimental evaluation of software development to.pdf}
}

@misc{LangserverOrg,
  title = {Langserver.Org},
  url = {https://langserver.org/},
  urldate = {2022-04-27},
  file = {/Users/ysander/Zotero/storage/K43FXR7T/langserver.org.html}
}

@misc{LanguageserverLibRs,
  title = {\#language-Server // {{Lib}}.Rs},
  journal = {Lib.rs},
  url = {https://lib.rs/keywords/language-server},
  urldate = {2022-03-14},
  abstract = {\#language-server = lsp-types, lspower, tower-lsp, svls, kak-lsp, ra\_ap\_rust-analyzer, tremor-language-server, cargo-rls-install, codespan-lsp, languageclient, etc.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/X9MSWKJE/language-server.html}
}

@article{lattnerLLVMClangNext2008,
  title = {{{LLVM}} and {{Clang}}: {{Next Generation Compiler Technology}}},
  author = {Lattner, Chris},
  year = {2008},
  month = may,
  volume = {BSDCan},
  pages = {33},
  url = {https://llvm.org/pubs/2008-05-17-BSDCan-LLVMIntro.pdf},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/WGH4G2KH/Lattner - LLVM and Clang Next Generation Compiler Technolog.pdf}
}

@inproceedings{lattnerLLVMCompilationFramework2004,
  title = {{{LLVM}}: A Compilation Framework for Lifelong Program Analysis Amp; Transformation},
  shorttitle = {{{LLVM}}},
  booktitle = {International {{Symposium}} on {{Code Generation}} and {{Optimization}}, 2004. {{CGO}} 2004.},
  author = {Lattner, C. and Adve, V.},
  year = {2004},
  month = mar,
  pages = {75--86},
  doi = {10.1109/CGO.2004.1281665},
  abstract = {We describe LLVM (low level virtual machine), a compiler framework designed to support transparent, lifelong program analysis and transformation for arbitrary programs, by providing high-level information to compiler transformations at compile-time, link-time, run-time, and in idle time between runs. LLVM defines a common, low-level code representation in static single assignment (SSA) form, with several novel features: a simple, language-independent type-system that exposes the primitives commonly used to implement high-level language features; an instruction for typed address arithmetic; and a simple mechanism that can be used to implement the exception handling features of high-level languages (and setjmp/longjmp in C) uniformly and efficiently. The LLVM compiler framework and code representation together provide a combination of key capabilities that are important for practical, lifelong analysis and transformation of programs. To our knowledge, no existing compilation approach provides all these capabilities. We describe the design of the LLVM representation and compiler framework, and evaluate the design in three ways: (a) the size and effectiveness of the representation, including the type information it provides; (b) compiler performance for several interprocedural problems; and (c) illustrative examples of the benefits LLVM provides for several challenging compiler problems.},
  keywords = {Algorithm design and analysis,Application software,Arithmetic,High level languages,Information analysis,Performance analysis,Program processors,Runtime,Software safety,Virtual machining},
  file = {/Users/ysander/Zotero/storage/UD9QTPKD/Lattner and Adve - 2004 - LLVM a compilation framework for lifelong program.pdf;/Users/ysander/Zotero/storage/WJDD86C3/1281665.html}
}

@mastersthesis{leimeisterLanguageServerIDE2020,
  title = {A {{Language Server}} and {{IDE Plugin}} for {{CPAchecker}}},
  author = {Leimeister, Adrian},
  year = {2020},
  month = mar,
  url = {https://www.sosy-lab.org/research/bsc/2020.Leimeister.A_Language_Server_and_IDE_Plugin_for_CPAchecker.pdf},
  abstract = {Formal verification of software is an useful addition to testing when trying to eliminate unwanted behavior and errors. Multiple approaches for formal verification exist, such as model checking or program analysis, for which a multitude of different tools exist. CPAchecker is a tool that makes it possible to combine advantages of both model checking and program analysis, and can be extended to include new verification ideas. With modern powerful, feature rich Integrated Development Environments (IDEs), most development tools are easy to integrated into a development workflow, but most verification tools are only available as commandline tools or via web interfaces. The solution proposed is an implementation of formal verification into IDEs with the help of the Language Server Protocol (LSP). This is realized by implementing the interfacing with CPAchecker as a LSP server, with accompanying plug-in for an IDE, for which Eclipse CDT for C/C++ Developers was chosen. The implementation is based on the Microsoft LSP, which means it can be used to implement the functionality for other IDEs with less effort. Feedback from an evaluation of the resulting tool, which was done by conducting a survey among potential users, was included in the final tool. In conclusion, the resulting language server and IDE plug-in are sufficient for basic use of formal verification.},
  langid = {english},
  school = {Ludwig-Maximilians-Universit\"at M\"unchen},
  file = {/Users/ysander/Zotero/storage/6447U6AL/Leimeister - A Language Server and IDE Plugin for CPAchecker.pdf}
}

@article{ListEclipsebasedSoftware2021,
  title = {List of {{Eclipse-based}} Software},
  year = {2021},
  month = nov,
  journal = {Wikipedia},
  url = {https://en.wikipedia.org/w/index.php?title=List_of_Eclipse-based_software&oldid=1053364228},
  urldate = {2022-02-19},
  abstract = {The Eclipse IDE platform can be extended by adding different plug-ins. Notable examples include: Acceleo, an open source code generator that uses EMF-based models to generate any textual language (Java, PHP, Python, etc.). Actifsource, a modeling and code generation workbench. Adobe ColdFusion Builder, the official Adobe IDE for ColdFusion. Adobe Flash Builder (formerly Adobe Flex Builder), an Adobe IDE based on Eclipse for building Flex applications for the Flash Platform and mobile platforms. ADT Eclipse plugin developed by Google for the Android SDK. AnyLogic, a simulation modeling tool developed by The AnyLogic Company. Appcelerator, a cross platform mobile development tool by Axway Appcelerator Aptana, Web IDE based on Eclipse Avaya Dialog Designer, a commercial IDE to build scripts for voice self-service applications. Bioclipse, a visual platform for chemo- and bioinformatics. BIRT Project, open source software project that provides reporting and business intelligence capabilities for rich client and web applications. Bonita Open Solution relies on Eclipse for the modeling of processes, implementing a BPMN and a Web form editors. Cantata IDE is a computer program for software testing at run time of C and C++ programs. CityEngine procedural based city generator. Code Composer Studio Texas Instruments' IDE for microcontroller development. CodeWarrior Freescale's IDE for microcontrollers, since Version 10 (C/C++/Assembly compilers). Compuware OptimalJ, a model-driven development environment for Java Coverity Static Analysis, which finds crash-causing defects and security vulnerabilities in code DBeaver, universal database manager and SQL client ECLAIR, a tool for automatic program analysis, verification, testing and transformation EasyEclipse, bundled distributions of the Eclipse IDE Elysium, a frontend for the LilyPond music-engraving program g-Eclipse, an integrated workbench framework to access the power of existing Grid infrastructures GForge Advanced Server - Collaboration tool with multiframe view through Eclipse integration for multiple functions Google Plugin for Eclipse, Development tools to design, build, optimize and deploy cloud applications to Google App Engine GumTree, an integrated workbench for instrument control and data analysis IBM Rational Application Developer for WebSphere Software, supporting design, development, analysis, testing, profiling and deployment of Java-based applications. It used to be named IBM WebSphere Studio Application Developer. IBM Rational Functional Tester is an automated functional regression testing tool to test Web, Java, .NET, Siebel, SAP and Oracle applications. IBM Rational Software Architect, supporting design with UML and development of applications. This product replaces some Rational Rose products family. IBM Rational Software Modeler is a robust, scalable solution for requirements elaboration, design, and general modeling. It supports design with UML. This product replaces some Rational Rose products family. IBM Rational Performance Tester is a performance testing tool used to identify the presence and cause of system performance bottlenecks. IBM Rational Method Composer, a software development process management and delivery platform IBM Rational Publishing Engine, a document generation solution IBM WebSphere Portlet Factory is a software tool to develop portlets. IBM Lotus Expeditor a client-server platform that provides a framework to develop lightweight rich client applications for desktops and various mobile devices. IBM Lotus Symphony a set of applications free of charge: a word processor, a spreadsheet program, and a presentation program, each based on OpenOffice.org IBM Notes (since version 8), a client-server collaborative application platform, used for enterprise email and calendaring, as well as for collaborative business applications. Intel FPGA (formerly Altera), Nios-II EDS, embedded C/C++ software development environment for Intel Nios-II and ARM processors in the HPS part of SoC FPGA's. Jasper Studio, a development environment for Jasper Reports Kalypso (software), an Open Source software project, that can be used as a general modeling system. It is focused mainly on numerical simulations in water management such as generation of concepts for flood prevention and protection or risk management. KNIME, an open source data analytics, reporting and integration platform. Maveryx plug-in to Eclipse. It is an Open Source tool that provides testers with automated testing capabilities for functional testing, regression testing, GUI testing and data-driven testing. MontaVista DevRocket, plug-in to Eclipse MyEclipse, from Genuitec is a robust, full featured, full-stack IDE solution which also enables Angular Typescript development from within the Java-Eclipse platform using its Webclipse plug-in and Angular IDE solution. Nodeclipse is Eclipse-based IDE for Node.js development. Nuxeo RCP, an open source rich client platform for ECM applications. OEPE, Oracle Enterprise Pack for Eclipse. OMNeT++, Network Simulation Framework. Parasoft C/C++test, an automated  C and C++ software testing tool for static analysis, Unit test-case generation and execution,  regression testing, runtime error detection, and code review. Parasoft Jtest,  an automated  Java software testing tool for static analysis, Unit test-case generation and execution,  regression testing, runtime error detection, and code review. Parasoft SOAtest  tool suite for testing and validating APIs and API-driven applications (e.g., cloud, mobile apps, SOA). Parasoft Virtualize, a service virtualization product that can create, deploy, and manage simulated test environments for software development and software testing purposes. Photran  is an open source IDE with functions for editing and debugging Fortran code. PHP Development Tools (or simply PDT) is an open source IDE with basic functions for editing and debugging PHP application. PHPEclipse is an open source PHP IDE with integrated debugging, developed and supported by a committed community. Polyspace detects and proves the absence of certain run-time errors in source code with a plugin for Eclipse for C, C++, and Ada languages Powerflasher FDT is an Eclipse-based integrated development environment for building Flex applications for the Flash Platform and mobile platforms. Pulse (ALM) from Genuitec is a free or for-fee service intended for Eclipse tool management and application delivery, collaboration and management. PyDev is an Integrated Development Environment (IDE) used for programming in Python supporting code refactoring, graphical debugging, code analysis among other features. Red Hat JBoss Developer Studio Remote Component Environment is an integration platform for engineers which enables integration, workflow management and data management in a distributed environment. RSSOwl, a Java RSS/RDF/Atom newsreader SAP NetWeaver Developer Studio, an IDE for most of the Java part of SAP technology Servoy, Servoy 4.0 is an Eclipse plug in to write business applications. Sirius allows creating custom graphical modeling workbenches by leveraging the Eclipse Modeling technologies, including EMF and GMF. Spatiotemporal Epidemiological Modeler (STEM), is an open source tool for creating and studying new mathematical models of Infectious Disease. SpringSource STS, plugin for Spring framework based development Sybase PowerDesigner, a data-modeling and collaborative design tool for enterprises that need to build or re-engineer applications. Teamcenter, from version 2007.1 this Product Lifecycle Management software uses Eclipse as platform. Talend STUDIO, an ETL IDE used to extract data from databases or csv files, treat the data, and load them to a database or csv file or a standard Tensilica Xtensa Xplorer, an IDE which  integrates software development, processor configuration and optimization, multiple-processor SOC architecture tools and SOC simulation into one common design environment. ThreadSafe, a static analysis tool for Java focused on finding and diagnosing concurrency bugs (race conditions, deadlocks, ...) uDig, a user-friendly GIS map-making program VistaMax IDE for Maemo, a visual Integrated Development Environment based on Eclipse VP/MS, Eclipse-based modeling language and product lifecycle management tool by CSC. WireframeSketcher, a wireframing tool for desktop, web and mobile applications. XMind, a cross-platform mind-mapping/brainstorming/presentation software application. Xilinx's EDK (Embedded Development Kit) is the development package for building MicroBlaze (and PowerPC) embedded processor systems in Xilinx FPGAs as part of the Xilinx IDE software (until version 14.7) Xilinx SDK as part of the newer Vivado design software package Zen Coding, A set of plugins for HTML and CSS hi-speed coding. Zend Studio An IDE used for developing PHP websites and web services. Zoom A profiling and performance analysis tool for Linux and Mac OS X.},
  copyright = {Creative Commons Attribution-ShareAlike License},
  langid = {english},
  annotation = {Page Version ID: 1053364228},
  file = {/Users/ysander/Zotero/storage/XTFLW5BL/List_of_Eclipse-based_software.html}
}

@misc{LLVMCompilerInfrastructure,
  title = {The {{LLVM Compiler Infrastructure Project}}},
  url = {https://llvm.org/ProjectsWithLLVM/},
  urldate = {2022-02-24},
  file = {/Users/ysander/Zotero/storage/JQEPJVGC/ProjectsWithLLVM.html}
}

@misc{LSPClientMaintainer2019,
  type = {Reddit {{Post}}},
  title = {A {{LSP}} Client Maintainer's View of the {{LSP}} Protocol.},
  year = {2019},
  month = mar,
  journal = {r/vim},
  url = {www.reddit.com/r/vim/comments/b3yzq4/a_lsp_client_maintainers_view_of_the_lsp_protocol/},
  urldate = {2021-12-04},
  file = {/Users/ysander/Zotero/storage/5FQ6I66K/a_lsp_client_maintainers_view_of_the_lsp_protocol.html}
}

@misc{Lspserver2022,
  title = {Lsp-Server},
  year = {2022},
  month = mar,
  url = {https://github.com/rust-analyzer/lsp-server},
  urldate = {2022-03-21},
  howpublished = {rust-analyzer}
}

@inproceedings{lungDifficultyReplicatingHuman2008,
  title = {On the Difficulty of Replicating Human Subjects Studies in Software Engineering},
  booktitle = {2008 {{ACM}}/{{IEEE}} 30th {{International Conference}} on {{Software Engineering}}},
  author = {Lung, Jonathan and Aranda, Jorge and Easterbrook, Steve and Wilson, Gregory},
  year = {2008},
  month = may,
  pages = {191--200},
  issn = {1558-1225},
  doi = {10.1145/1368088.1368115},
  abstract = {Replications play an important role in verifying empirical results. In this paper, we discuss our experiences performing a literal replication of a human subjects experiment that examined the relationship between a simple test for consistent use of mental models, and success in an introductory programming course. We encountered many difficulties in achieving comparability with the original experiment, due to a series of apparently minor differences in context. Based on this experience, we discuss the relative merits of replication, and suggest that, for some human subjects studies, literal replication may not be the the most effective strategy for validating the results of previous studies.},
  keywords = {Cognitive science,Collaboration,Data analysis,empirical,experience report,human subjects,Humans,Lungs,Packaging,Performance evaluation,Permission,replication,Software engineering,Testing},
  file = {/Users/ysander/Zotero/storage/2WZYU9FM/Lung et al. - 2008 - On the difficulty of replicating human subjects st.pdf;/Users/ysander/Zotero/storage/K3XQH6VX/4814130.html}
}

@article{matsakisRustLanguage2014,
  title = {The Rust Language},
  author = {Matsakis, Nicholas D. and Klock, Felix S.},
  year = {2014},
  month = oct,
  journal = {ACM SIGAda Ada Letters},
  volume = {34},
  number = {3},
  pages = {103--104},
  issn = {1094-3641},
  doi = {10.1145/2692956.2663188},
  url = {https://doi.org/10.1145/2692956.2663188},
  urldate = {2022-05-01},
  abstract = {Rust is a new programming language for developing reliable and efficient systems. It is designed to support concurrency and parallelism in building applications and libraries that take full advantage of modern hardware. Rust's static type system is safe1 and expressive and provides strong guarantees about isolation, concurrency, and memory safety. Rust also offers a clear performance model, making it easier to predict and reason about program efficiency. One important way it accomplishes this is by allowing fine-grained control over memory representations, with direct support for stack allocation and contiguous record storage. The language balances such controls with the absolute requirement for safety: Rust's type system and runtime guarantee the absence of data races, buffer overflows, stack overflows, and accesses to uninitialized or deallocated memory.},
  keywords = {affine type systems,memory management,rust,systems programming},
  file = {/Users/ysander/Zotero/storage/KB7E8GA9/Matsakis and Klock - 2014 - The rust language.pdf}
}

@inproceedings{meszarosDeliveringComprehensionFeatures2019,
  title = {Delivering Comprehension Features into Source Code Editors through {{LSP}}},
  booktitle = {2019 42nd {{International Convention}} on {{Information}} and {{Communication Technology}}, {{Electronics}} and {{Microelectronics}} ({{MIPRO}})},
  author = {M{\'e}sz{\'a}ros, M{\'o}nika and Cser{\'e}p, M{\'a}t{\'e} and Fekete, Anett},
  year = {2019},
  month = may,
  pages = {1581--1586},
  issn = {2623-8764},
  doi = {10.23919/MIPRO.2019.8756695},
  abstract = {The maintenance of large, legacy software often results in higher development time and cost due to increasing size and complexity of the codebase and its documentation, their continuously eroding quality and fluctuation among developers. Code comprehension tools are designed to tackle this issue by providing various textual information, visualization views and source code metrics on multiple abstraction levels. These tools usually process not only the codebase, but also the build information, the version control repository and other available information sources. Meanwhile source code editors and integrated development environments (IDEs) are not performing well in the field of code comprehension as they are optimized for writing new code, not for effective browsing. This can easily result in frequent switching between environments during development, hindering effective programming and raising development cost. Language Server Protocol (LSP) is an open-source protocol to connect source code editors with servers that provide language-specific features. In this research we analyze how LSP can be utilized to improve the code comprehension experience inside code editors by integrating the features of such tools through remote procedure calls. As a prototype solution we showcase the integration of two open-source applications: Visual Studio Code and the Code Compass code comprehension tool.},
  keywords = {code comprehension,language server protocol,software maintenance,source code editor},
  file = {/Users/ysander/Zotero/storage/YQDR9EFM/Mészáros et al. - 2019 - Delivering comprehension features into source code.pdf;/Users/ysander/Zotero/storage/3RSJX493/8756695.html}
}

@inproceedings{meyerovichEmpiricalAnalysisProgramming2013,
  title = {Empirical Analysis of Programming Language Adoption},
  booktitle = {Proceedings of the 2013 {{ACM SIGPLAN}} International Conference on {{Object}} Oriented Programming Systems Languages \& Applications},
  author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
  year = {2013},
  month = oct,
  series = {{{OOPSLA}} '13},
  pages = {1--18},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/2509136.2509515},
  url = {https://doi.org/10.1145/2509136.2509515},
  urldate = {2021-12-21},
  abstract = {Some programming languages become widely popular while others fail to grow beyond their niche or disappear altogether. This paper uses survey methodology to identify the factors that lead to language adoption. We analyze large datasets, including over 200,000 SourceForge projects, 590,000 projects tracked by Ohloh, and multiple surveys of 1,000-13,000 programmers. We report several prominent findings. First, language adoption follows a power law; a small number of languages account for most language use, but the programming market supports many languages with niche user bases. Second, intrinsic features have only secondary importance in adoption. Open source libraries, existing code, and experience strongly influence developers when selecting a language for a project. Language features such as performance, reliability, and simple semantics do not. Third, developers will steadily learn and forget languages. The overall number of languages developers are familiar with is independent of age. Finally, when considering intrinsic aspects of languages, developers prioritize expressivity over correctness. They perceive static types as primarily helping with the latter, hence partly explaining the popularity of dynamic languages.},
  isbn = {978-1-4503-2374-1},
  keywords = {programming language adoption,survey research},
  file = {/Users/ysander/Zotero/storage/JFBFEQIY/Meyerovich and Rabkin - 2013 - Empirical analysis of programming language adoptio.pdf}
}

@inproceedings{meyerovichSocioPLTPrinciplesProgramming2012a,
  title = {Socio-{{PLT}}: Principles for Programming Language Adoption},
  shorttitle = {Socio-{{PLT}}},
  booktitle = {Proceedings of the {{ACM}} International Symposium on {{New}} Ideas, New Paradigms, and Reflections on Programming and Software - {{Onward}}! '12},
  author = {Meyerovich, Leo A. and Rabkin, Ariel S.},
  year = {2012},
  pages = {39},
  publisher = {{ACM Press}},
  address = {{Tucson, Arizona, USA}},
  doi = {10.1145/2384592.2384597},
  url = {http://dl.acm.org/citation.cfm?doid=2384592.2384597},
  urldate = {2021-12-21},
  abstract = {Why do some programming languages fail and others succeed? What does the answer tell us about programming language design, implementation, and principles? To help answer these and other questions, we argue for examining the sociological groundings of programming language theory: socio-PLT.},
  isbn = {978-1-4503-1562-3},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/IPYUYMIQ/Meyerovich and Rabkin - 2012 - Socio-PLT principles for programming language ado.pdf}
}

@misc{microsoftLanguageServerProtocol2020,
  title = {Language {{Server Protocol Specification}} - 3.16},
  author = {{Microsoft}},
  year = {2020},
  month = dec,
  url = {https://microsoft.github.io/language-server-protocol/specification.html},
  urldate = {2021-07-28},
  file = {/Users/ysander/Zotero/storage/XZ7CTGBY/specification.html}
}

@misc{microsoftLanguageServers,
  title = {Language {{Servers}}},
  author = {{Microsoft}},
  url = {https://microsoft.github.io/language-server-protocol/implementors/servers/},
  urldate = {2022-05-01},
  file = {/Users/ysander/Zotero/storage/6F6XBMSS/servers.html}
}

@misc{microsoftVisualStudioCode,
  title = {Visual {{Studio Code}} - {{Code Editing}}. {{Redefined}}},
  author = {Microsoft},
  url = {https://code.visualstudio.com/},
  urldate = {2022-05-08},
  file = {/Users/ysander/Zotero/storage/6TZWSJG5/code.visualstudio.com.html}
}

@inproceedings{mitchellBuildingIntegratedDevelopment2020,
  title = {Building an {{Integrated Development Environment}} ({{IDE}}) on Top of a {{Build System}}: {{The}} Tale of a {{Haskell IDE}}},
  shorttitle = {Building an {{Integrated Development Environment}} ({{IDE}}) on Top of a {{Build System}}},
  booktitle = {{{IFL}} 2020: {{Proceedings}} of the 32nd {{Symposium}} on {{Implementation}} and {{Application}} of {{Functional Languages}}},
  author = {Mitchell, Neil and Kiefer, Moritz and Iborra, Pepe and Lau, Luke and Duggal, Zubin and Siebenhandl, Hannes and Sanchez, Javier Neira and Pickering, Matthew and Zimmerman, Alan},
  year = {2020},
  month = sep,
  pages = {1--10},
  publisher = {{ACM}},
  address = {{Canterbury United Kingdom}},
  doi = {10.1145/3462172.3462180},
  url = {https://dl.acm.org/doi/10.1145/3462172.3462180},
  urldate = {2021-11-12},
  abstract = {When developing a Haskell IDE we hit upon an idea \textendash{} why not base an IDE on an build system? In this paper we'll explain how to go from that idea to a usable IDE, including the difficulties imposed by reusing a build system, and those imposed by technical details specific to Haskell. Our design has been successful, and hopefully provides a blue-print for others writing IDEs.},
  isbn = {978-1-4503-8963-1},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/2355YHQQ/Mitchell et al. - 2020 - Building an Integrated Development Environment (ID.pdf}
}

@misc{MonacoEditor2022,
  title = {Monaco {{Editor}}},
  year = {2022},
  month = may,
  url = {https://github.com/microsoft/monaco-editor},
  urldate = {2022-05-01},
  abstract = {A browser based code editor},
  copyright = {MIT},
  howpublished = {Microsoft},
  keywords = {browser,editor,monaco-editor,typescript,vscode}
}

@article{murphyHowAreJava2006,
  title = {How Are {{Java}} Software Developers Using the {{Elipse IDE}}?},
  author = {Murphy, G.C. and Kersten, M. and Findlater, L.},
  year = {2006},
  month = jul,
  journal = {IEEE Software},
  volume = {23},
  number = {4},
  pages = {76--83},
  issn = {1937-4194},
  doi = {10.1109/MS.2006.105},
  abstract = {The Eclipse integrated development environment continues to gain popularity among Java developers. Our usage monitoring approach allows tool builders to sample how developers are using their tools in the wild. The data gathered about tool use can be used to prevent feature bloat and to evolve the environments according to user needs. Information about how developers work in a development environment can also provide a baseline for assessing new software development tools. We hope this report provides a start in defining which in formation to collect and distribute on an on going basis to help improve Eclipse and other similar platforms and tools},
  keywords = {Application software,coding tools and techniques,Computer architecture,construction tools,Financial management,History,Instruments,Java,Monitoring,programming environments,Software tools,Standards development,XML},
  file = {/Users/ysander/Zotero/storage/SHIXGE5Q/Murphy et al. - 2006 - How are Java software developers using the Elipse .pdf;/Users/ysander/Zotero/storage/VJRXQFTF/1657944.html}
}

@misc{NetWhatAre,
  title = {.Net - {{What}} Are Row Types? {{Are}} They Algebraic Data Types?},
  shorttitle = {.Net - {{What}} Are Row Types?},
  journal = {Stack Overflow},
  url = {https://stackoverflow.com/questions/48092739/what-are-row-types-are-they-algebraic-data-types},
  urldate = {2022-01-05},
  file = {/Users/ysander/Zotero/storage/5AMWLRVI/what-are-row-types-are-they-algebraic-data-types.html}
}

@article{neville-neilCodeSpelunkingExploring2003,
  title = {Code {{Spelunking}}: {{Exploring Cavernous Code Bases}}: {{Code}} Diving through Unfamiliar Source Bases Is Something We Do Far More Often than Write New Code from Scratch--Make Sure You Have the Right Gear for the Job.},
  shorttitle = {Code {{Spelunking}}},
  author = {{Neville-Neil}, George V.},
  year = {2003},
  month = sep,
  journal = {Queue},
  volume = {1},
  number = {6},
  pages = {42--48},
  issn = {1542-7730},
  doi = {10.1145/945131.945136},
  url = {https://doi.org/10.1145/945131.945136},
  urldate = {2021-11-08},
  abstract = {Try to remember your first day at your first software job. Do you recall what you were asked to do, after the human resources people were done with you? Were you asked to write a piece of fresh code? Probably not. It is far more likely that you were asked to fix a bug, or several, and to try to understand a large, poorly documented collection of source code. Of course, this doesn't just happen to new graduates; it happens to all of us whenever we start a new job or look at a new piece of code. With experience we all develop a set of techniques for working with large, unfamiliar source bases. This is what I call code spelunking.},
  file = {/Users/ysander/Zotero/storage/WPKYF3SQ/Neville-Neil - 2003 - Code Spelunking Exploring Cavernous Code Bases C.pdf}
}

@misc{NginixNgiNext,
  title = {Ngi-Nix/Ngi: {{Next Generation Internet}} Admin Stuff},
  shorttitle = {Ngi-Nix/Ngi},
  journal = {GitHub},
  url = {https://github.com/ngi-nix/ngi},
  urldate = {2021-08-17},
  abstract = {Next Generation Internet admin stuff. Contribute to ngi-nix/ngi development by creating an account on GitHub.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/NP4DNDG8/217.html}
}

@misc{Nix2022,
  title = {Nix},
  year = {2022},
  month = may,
  url = {https://github.com/NixOS/nix},
  urldate = {2022-05-01},
  abstract = {Nix, the purely functional package manager},
  copyright = {LGPL-2.1},
  howpublished = {Nix/Nixpkgs/NixOS},
  keywords = {c-plus-plus,declarative-language,functional-programming,nix,package-manager}
}

@misc{NixOSNixOSLinux,
  title = {{{NixOS}} - {{NixOS Linux}}},
  url = {https://nixos.org/},
  urldate = {2022-05-01},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/45QAJDCT/nixos.org.html}
}

@misc{nvidiaCUDACompilerDriver2022,
  title = {{{CUDA Compiler Driver NVCC}}},
  author = {{NVIDIA}},
  year = {2022},
  month = may,
  url = {https://docs.nvidia.com/cuda/pdf/CUDA_Compiler_Driver_NVCC.pdf},
  file = {/Users/ysander/Zotero/storage/ML7SB4MM/CUDA Compiler Driver NVCC.pdf}
}

@misc{ocamlcommunityOCamlMerlin,
  title = {{{OCaml}} - {{Merlin}}},
  author = {{OCaml Community}},
  journal = {An editor service that provides advanced IDE features for OCaml.},
  url = {https://ocaml.github.io/merlin/},
  urldate = {2022-02-20},
  file = {/Users/ysander/Zotero/storage/FFW3AQKZ/merlin.html}
}

@misc{OCamlLSP2022,
  title = {{{OCaml Language Server Protocol}} Implementation},
  author = {{OCaml Community}},
  year = {2022},
  month = apr,
  url = {https://github.com/ocaml/ocaml-lsp},
  urldate = {2022-05-01},
  abstract = {OCaml Language Server Protocol implementation},
  howpublished = {OCaml}
}

@misc{Outlook,
  title = {Outlook},
  url = {https://webmail.kth.se/owa/auth/logon.aspx?replaceCurrent=1&url=https%3a%2f%2fwebmail.kth.se%2fowa%2f},
  urldate = {2022-04-30}
}

@misc{Ownership,
  title = {Ownership},
  url = {https://doc.rust-lang.org/1.8.0/book/ownership.html},
  urldate = {2022-03-14}
}

@misc{Ownershipa,
  title = {Ownership},
  url = {https://doc.rust-lang.org/1.8.0/book/ownership.html},
  urldate = {2022-03-14}
}

@misc{Ownershipb,
  title = {Ownership},
  url = {https://doc.rust-lang.org/1.8.0/book/ownership.html},
  urldate = {2022-03-14},
  file = {/Users/ysander/Zotero/storage/2HPWSBJM/ownership.html}
}

@misc{PartTenStarting,
  title = {Part {{Ten}}: {{Starting Again}} {$\cdot$} Arzg's Website},
  url = {https://arzg.github.io/lang/10/},
  urldate = {2021-09-13},
  file = {/Users/ysander/Zotero/storage/2E44D5UR/10.html}
}

@incollection{pechJetBrainsMPSWhy2021,
  title = {{{JetBrains MPS}}: {{Why Modern Language Workbenches Matter}}},
  shorttitle = {{{JetBrains MPS}}},
  booktitle = {Domain-{{Specific Languages}} in {{Practice}}: With {{JetBrains MPS}}},
  author = {Pech, V{\'a}clav},
  editor = {Bucchiarone, Antonio and Cicchetti, Antonio and Ciccozzi, Federico and Pierantonio, Alfonso},
  year = {2021},
  pages = {1--22},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-030-73758-0_1},
  url = {https://doi.org/10.1007/978-3-030-73758-0_1},
  urldate = {2022-05-08},
  abstract = {The goal of this chapter is to give a perspective on language workbenches, as well as to provide an overview of the MPS features. It starts with an introduction to language workbenches and motivations for DSL development. It then continues with an overview of how languages are created in MPS. Projectional editing is explained and its benefits for DSL design discussed. Other essential aspects of language definition, such as language testing and migration, are covered as well. Finally, useful pointers regarding the MPS ecosystem and the user community are provided.},
  isbn = {978-3-030-73758-0},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/ZBEMMZZI/Pech - 2021 - JetBrains MPS Why Modern Language Workbenches Mat.pdf}
}

@inproceedings{pelsmaekerLanguageparametricSemanticEditor2019,
  title = {Towards Language-Parametric Semantic Editor Services Based on Declarative Type System Specifications},
  booktitle = {Proceedings {{Companion}} of the 2019 {{ACM SIGPLAN International Conference}} on {{Systems}}, {{Programming}}, {{Languages}}, and {{Applications}}: {{Software}} for {{Humanity}}},
  author = {Pelsmaeker, Daniel A. A. and {van Antwerpen}, Hendrik and Visser, Eelco},
  year = {2019},
  month = oct,
  series = {{{SPLASH Companion}} 2019},
  pages = {19--20},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3359061.3362782},
  url = {https://doi.org/10.1145/3359061.3362782},
  urldate = {2021-12-21},
  abstract = {New programming languages often lack good IDE support, as developing advanced semantic editor services takes additional effort. In previous work we discussed the operational requirements of a constraint solver that leverages the declarative type system specification of a language to provide language-parametric semantic editor services. In this work we describe the implementation of our solver as a two stage process: inference and search. An editor-service specific search strategy determines how and where the search is conducted, and when it terminates. We are currently implementing and evaluating this idea.},
  isbn = {978-1-4503-6992-3},
  keywords = {constraint programming,constraint solving,editor services,semantics,Spoofax,Statix},
  file = {/Users/ysander/Zotero/storage/USJE4PKL/Pelsmaeker et al. - 2019 - Towards language-parametric semantic editor servic.pdf}
}

@inproceedings{porkolabCodecompassOpenSoftware2018,
  title = {Codecompass: An Open Software Comprehension Framework for Industrial Usage},
  shorttitle = {Codecompass},
  booktitle = {Proceedings of the 26th {{Conference}} on {{Program Comprehension}}},
  author = {Porkol{\'a}b, Zolt{\'a}n and Brunner, Tibor and Krupp, D{\'a}niel and Csord{\'a}s, M{\'a}rton},
  year = {2018},
  month = may,
  series = {{{ICPC}} '18},
  pages = {361--369},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3196321.3197546},
  url = {https://doi.org/10.1145/3196321.3197546},
  urldate = {2022-02-25},
  abstract = {CodeCompass is an open source LLVM/Clang-based tool developed by Ericsson Ltd. and E\"otv\"os Lor\'and University, Budapest to help the understanding of large legacy software systems. Based on the LLVM/Clang compiler infrastructure, CodeCompass gives exact information on complex C/C++ language elements like overloading, inheritance, the usage of variables and types, possible uses of function pointers and virtual functions - features that various existing tools support only partially. Steensgaard's and Andersen's pointer analysis algorithms are used to compute and visualize the use of pointers/references. The wide range of interactive visualizations extends further than the usual class and function call diagrams; architectural, component and interface diagrams are a few of the implemented graphs. To make comprehension more extensive, CodeCompass also utilizes build information to explore the system architecture as well as version control information. CodeCompass is regularly used by hundreds of designers and developers. Having a web-based, pluginable, extensible architecture, the CodeCompass framework can be an open platform to further code comprehension, static analysis and software metrics efforts. The source code and a tutorial is publicly available on GitHub, and a live demo is also available online.},
  isbn = {978-1-4503-5714-2},
  keywords = {C/C++ programming language,code comprehension,software visualization},
  file = {/Users/ysander/Zotero/storage/TSRXWQHI/Porkoláb et al. - 2018 - Codecompass an open software comprehension framew.pdf}
}

@mastersthesis{raskDecouplingCoreAnalysis2021,
  title = {Decoupling of {{Core Analysis Support}} for {{Specification Languages}} from {{User Interfaces}} in {{Integrated Development Environments}}},
  author = {Rask, Jonas and Madsen, Frederik},
  year = {2021},
  month = jan,
  doi = {10.13140/RG.2.2.21889.99686},
  abstract = {Decoupling the core analysis support from the User Interface (UI) in Integrated Development Environments (IDEs) enables extensive reuse when implementing language support in multiple IDEs. This can be achieved by utilising a client-serverarchitecture to decouple the UI from the core analysis support. Communication between the processes in the decoupled architecture is facilitated using a language-neutral protocol to enable a language-agnostic client and a language-specific server to communicate which allows the client to be used with multiple servers and vice versa. For IDEs that support programming languages there is already a tendency to use this solution but, as this thesis finds, the existing language-neutral protocols Language Server Protocol (LSP) and Debug Adapter Protocol (DAP) lacks support for several language features found in specification languages. Therefore, this thesis proposes a new language-neutral protocol, called the Specification Language Server Protocol (SLSP), that is able to support language features specific to specification languages. To demonstrate that the language-neutral protocol can facilitate support for specification languages, a pilot study is conducted. In the pilot study a Proof of Con-cept (PoC) is implemented that provides support for Vienna Development Method (VDM) in Visual Studio Code (VS Code) using the language-neutral protocols. From the work presented in this thesis it is concluded that it is feasible to support specification language features in the SLSP protocol and to employ the protocol in a client-server architecture that decouples the UI from the core language analysis support. However, the SLSP protocol needs further testing with other specification languages than VDM to validate that it is generally applicable.},
  school = {Aarhus University}
}

@article{raskSpecificationLanguageServer2021,
  title = {The {{Specification Language Server Protocol}}: {{A Proposal}} for {{Standardised LSP Extensions}}},
  shorttitle = {The {{Specification Language Server Protocol}}},
  author = {Rask, Jonas Kj{\ae}r and Madsen, Frederik Palludan and Battle, Nick and Macedo, Hugo Daniel and Larsen, Peter Gorm},
  year = {2021},
  month = aug,
  journal = {Electronic Proceedings in Theoretical Computer Science},
  volume = {338},
  eprint = {2108.02961},
  eprinttype = {arxiv},
  pages = {3--18},
  issn = {2075-2180},
  doi = {10.4204/EPTCS.338.3},
  url = {http://arxiv.org/abs/2108.02961},
  urldate = {2022-02-15},
  abstract = {The Language Server Protocol (LSP) changed the field of Integrated Development Environments(IDEs), as it decouples core (programming) language features functionality from editor smarts, thus lowering the effort required to extend an IDE to support a language. The concept is a success and has been adopted by several programming languages and beyond. This is shown by the emergence of several LSP implementations for the many programming and specification languages (languages with a focus on modelling, reasoning, or proofs). However, for such languages LSP has been ad-hocly extended with the additional functionalities that are typically not found for programming languages and thus not supported in LSP. This foils the original LSP decoupling goal, because the move towards a new IDE requires yet another re-implementation of the ad-hoc LSP extension. In this paper we contribute with a conservative extension of LSP providing a first proposal towards a standard protocol decoupling the support of specification languages from the IDE. We hope our research attracts the larger community and motivates the need of a joint task force leading to a standardised LSP extension serving the particular needs of specification languages.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Software Engineering,rw},
  file = {/Users/ysander/Zotero/storage/Y73ZHQGG/Rask et al. - 2021 - The Specification Language Server Protocol A Prop.pdf;/Users/ysander/Zotero/storage/69KZI7WV/2108.html}
}

@book{raskSpecificationLanguageServer2021a,
  title = {The {{Specification Language Server Protocol}}: {{A Proposal}} for {{Standardised LSP Extensions}}},
  shorttitle = {The {{Specification Language Server Protocol}}},
  author = {Rask, Jonas and Madsen, Frederik and Battle, Nick and Macedo, Hugo and Larsen, Peter},
  year = {2021},
  month = aug,
  abstract = {The Language Server Protocol (LSP) changed the field of Integrated Development Environments(IDEs), as it decouples core (programming) language features functionality from editor smarts, thus lowering the effort required to extend an IDE to support a language. The concept is a success and has been adopted by several programming languages and beyond. This is shown by the emergence of several LSP implementations for the many programming and specification languages (languages with a focus on modelling, reasoning, or proofs). However, for such languages LSP has been ad-hocly extended with the additional functionalities that are typically not found for programming languages and thus not supported in LSP. This foils the original LSP decoupling goal, because the move towards a new IDE requires yet another re-implementation of the ad-hoc LSP extension. In this paper we contribute with a conservative extension of LSP providing a first proposal towards a standard protocol decoupling the support of specification languages from the IDE. We hope our research attracts the larger community and motivates the need of a joint task force leading to a standardised LSP extension serving the particular needs of specification languages.},
  file = {/Users/ysander/Zotero/storage/H4QV39IH/Rask et al. - 2021 - The Specification Language Server Protocol A Prop.pdf}
}

@misc{ReferencesBorrowing,
  title = {References and {{Borrowing}}},
  url = {https://doc.rust-lang.org/1.8.0/book/references-and-borrowing.html},
  urldate = {2022-03-14},
  file = {/Users/ysander/Zotero/storage/L9JWCRSF/references-and-borrowing.html}
}

@misc{replitCollaborativeBrowserBased,
  title = {The Collaborative Browser Based {{IDE}}},
  author = {{replit}},
  journal = {replit},
  url = {https://replit.com/},
  urldate = {2021-12-21},
  abstract = {Replit is a simple yet powerful online IDE, Editor, Compiler, Interpreter, and REPL. Code, compile, run, and host in 50+ programming languages.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/2G3Y9GMZ/replit.com.html}
}

@article{riedDesignImplementationCluster,
  title = {Design and {{Implementation}} of a {{Cluster Based Approach}} for {{Software Verification}}},
  author = {Ried, Alexander and Friedberger, Karlheinz and Beyer, Dr Dirk},
  pages = {29},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/9SDN58G9/Ried et al. - Design and Implementation of a Cluster Based Appro.pdf}
}

@misc{Rnixlsp2022,
  title = {Rnix-Lsp},
  year = {2022},
  month = apr,
  url = {https://github.com/nix-community/rnix-lsp},
  urldate = {2022-05-01},
  abstract = {WIP Language Server for Nix! [maintainer=@aaronjanse]},
  copyright = {MIT},
  howpublished = {Nix community projects}
}

@misc{Rnixparser2022,
  title = {Rnix-Parser},
  year = {2022},
  month = may,
  url = {https://github.com/nix-community/rnix-parser},
  urldate = {2022-05-01},
  abstract = {A Nix parser written in Rust [maintainer=@Ma27]},
  copyright = {MIT},
  howpublished = {Nix community projects}
}

@article{robbesImprovingCodeCompletion2010,
  title = {Improving Code Completion with Program History},
  author = {Robbes, Romain and Lanza, Michele},
  year = {2010},
  month = jun,
  journal = {Automated Software Engineering},
  volume = {17},
  number = {2},
  pages = {181--212},
  issn = {0928-8910, 1573-7535},
  doi = {10.1007/s10515-010-0064-x},
  url = {http://link.springer.com/10.1007/s10515-010-0064-x},
  urldate = {2021-11-08},
  abstract = {Code completion is a widely used productivity tool. It takes away the burden of remembering and typing the exact names of methods or classes: As a developer starts typing a name, it provides a progressively refined list of candidates matching the name. However, the candidate list usually comes in alphabetic order, i.e., the environment is only second-guessing the name based on pattern matching, relying on human intervention to pick the correct one. Finding the correct candidate can thus be cumbersome or slower than typing the full name.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/GEMG3SGW/Robbes and Lanza - 2010 - Improving code completion with program history.pdf}
}

@inproceedings{rodriguez-echeverriaLanguageServerProtocol2018,
  title = {Towards a {{Language Server Protocol Infrastructure}} for {{Graphical Modeling}}},
  booktitle = {Proceedings of the 21th {{ACM}}/{{IEEE International Conference}} on {{Model Driven Engineering Languages}} and {{Systems}}},
  author = {{Rodriguez-Echeverria}, Roberto and Izquierdo, Javier Luis C{\'a}novas and Wimmer, Manuel and Cabot, Jordi},
  year = {2018},
  month = oct,
  series = {{{MODELS}} '18},
  pages = {370--380},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3239372.3239383},
  url = {https://doi.org/10.1145/3239372.3239383},
  urldate = {2022-03-01},
  abstract = {The development of modern IDEs is still a challenging and time-consuming task, which requires implementing the support for language-specific features such as syntax highlighting or validation. When the IDE targets a graphical language, its development becomes even more complex due to the rendering and manipulation of the graphical notation symbols. To simplify the development of IDEs, the Language Server Protocol (LSP) proposes a decoupled approach based on language-agnostic clients and language-specific servers. LSP clients communicate changes to LSP servers, which validate and store language instances. However, LSP only addresses textual languages (i.e., character as atomic unit) and neglects the support for graphical ones (i.e., nodes/edges as atomic units). In this paper, we present our vision to decouple graphical language IDEs discussing the alternatives for integrating LSP's ideas in their development. Moreover, we propose a novel LSP infrastructure to simplify the development of new graphical modeling tools, in which Web technologies may be used for editor front-ends while leveraging existing modeling frameworks to build language servers.},
  isbn = {978-1-4503-4949-9},
  keywords = {Domain Specific Languages,Language Server Protocol,Modeling Editors},
  file = {/Users/ysander/Zotero/storage/Y3RJZ5LK/Rodriguez-Echeverria et al. - 2018 - Towards a Language Server Protocol Infrastructure .pdf}
}

@inproceedings{rodriguez-echeverriaLanguageServerProtocol2018a,
  title = {Towards a {{Language Server Protocol Infrastructure}} for {{Graphical Modeling}}},
  booktitle = {Proceedings of the 21th {{ACM}}/{{IEEE International Conference}} on {{Model Driven Engineering Languages}} and {{Systems}}},
  author = {{Rodriguez-Echeverria}, Roberto and Izquierdo, Javier Luis C{\'a}novas and Wimmer, Manuel and Cabot, Jordi},
  year = {2018},
  month = oct,
  series = {{{MODELS}} '18},
  pages = {370--380},
  publisher = {{Association for Computing Machinery}},
  address = {{New York, NY, USA}},
  doi = {10.1145/3239372.3239383},
  url = {https://doi.org/10.1145/3239372.3239383},
  urldate = {2022-02-18},
  abstract = {The development of modern IDEs is still a challenging and time-consuming task, which requires implementing the support for language-specific features such as syntax highlighting or validation. When the IDE targets a graphical language, its development becomes even more complex due to the rendering and manipulation of the graphical notation symbols. To simplify the development of IDEs, the Language Server Protocol (LSP) proposes a decoupled approach based on language-agnostic clients and language-specific servers. LSP clients communicate changes to LSP servers, which validate and store language instances. However, LSP only addresses textual languages (i.e., character as atomic unit) and neglects the support for graphical ones (i.e., nodes/edges as atomic units). In this paper, we present our vision to decouple graphical language IDEs discussing the alternatives for integrating LSP's ideas in their development. Moreover, we propose a novel LSP infrastructure to simplify the development of new graphical modeling tools, in which Web technologies may be used for editor front-ends while leveraging existing modeling frameworks to build language servers.},
  isbn = {978-1-4503-4949-9},
  keywords = {Domain Specific Languages,Language Server Protocol,Modeling Editors},
  file = {/Users/ysander/Zotero/storage/TEZKCTLG/Rodriguez-Echeverria et al. - 2018 - Towards a Language Server Protocol Infrastructure .pdf}
}

@misc{RustContainerCheat,
  title = {Rust Container Cheat Sheet},
  url = {https://docs.google.com/presentation/d/1q-c7UAyrUlM-eZyTo1pd8SZ0qwA_wYxmPZVOQkoDmH4},
  urldate = {2021-10-19},
  file = {/Users/ysander/Zotero/storage/5UEYUC94/Rust container cheat sheet.pdf}
}

@book{sauroQuantifyingUserExperience2016,
  title = {Quantifying the {{User Experience}}: {{Practical Statistics}} for {{User Research}}},
  shorttitle = {Quantifying the {{User Experience}}},
  author = {Sauro, Jeff and Lewis, James R.},
  year = {2016},
  month = jul,
  publisher = {{Morgan Kaufmann}},
  abstract = {Quantifying the User Experience: Practical Statistics for User Research, Second Edition, provides practitioners and researchers with the information they need to confidently quantify, qualify, and justify their data. The book presents a practical guide on how to use statistics to solve common quantitative problems that arise in user research. It addresses questions users face every day, including, Is the current product more usable than our competition? Can we be sure at least 70\% of users can complete the task on their first attempt? How long will it take users to purchase products on the website?  This book provides a foundation for statistical theories and the best practices needed to apply them. The authors draw on decades of statistical literature from human factors, industrial engineering, and psychology, as well as their own published research, providing both concrete solutions (Excel formulas and links to their own web-calculators), along with an engaging discussion on the statistical reasons why tests work and how to effectively communicate results. Throughout this new edition, users will find updates on standardized usability questionnaires, a new chapter on general linear modeling (correlation, regression, and analysis of variance), with updated examples and case studies throughout. Completely updated to provide practical guidance on solving usability testing problems with statistics for any project, including those using Six Sigma practices Includes new and revised information on standardized usability questionnaires Includes a completely new chapter introducing correlation, regression, and analysis of variance Shows practitioners which test to use, why they work, and best practices for application, along with easy-to-use Excel formulas and web-calculators for analyzing data Recommends ways for researchers and practitioners to communicate results to stakeholders in plain English},
  googlebooks = {USPfCQAAQBAJ},
  isbn = {978-0-12-802548-2},
  langid = {english},
  keywords = {Computers / Human-Computer Interaction (HCI)}
}

@misc{scalacenterBuildServerProtocol,
  title = {Build {{Server Protocol}} {$\cdot$} {{Protocol}} for {{IDEs}} and Build Tools to Communicate about Compile, Run, Test, Debug and More.},
  author = {{Scala Center} and {Jetbrains}},
  url = {https://build-server-protocol.github.io/},
  urldate = {2022-05-01},
  abstract = {Protocol for IDEs and build tools to communicate about compile, run, test, debug and more.},
  file = {/Users/ysander/Zotero/storage/E3IGV7FM/build-server-protocol.github.io.html}
}

@misc{scharliTraitsComposableUnits2002,
  title = {Traits: {{Composable Units}} of {{Behavior}}},
  shorttitle = {Traits},
  author = {Sch{\"a}rli, Nathanael and Ducasse, St{\'e}phane and Nierstrasz, Oscar and Black, Andrew},
  year = {2002},
  file = {/Users/ysander/Zotero/storage/NZAULSRE/Schärli et al. - 2002 - Traits Composable Units of Behavior.pdf;/Users/ysander/Zotero/storage/8KPRIWNF/summary.html}
}

@article{schenkelModernIDESupport,
  title = {Modern {{IDE Support}} for {{Functional Programming}}},
  author = {Schenkel, Cyrill},
  pages = {31},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/PFX849DZ/Schenkel - Modern IDE Support for Functional Programming.pdf}
}

@article{siekGradualTypingFunctional2006,
  title = {Gradual {{Typing}} for {{Functional Languages}}},
  author = {Siek, Jeremy G and Taha, Walid},
  year = {2006},
  pages = {12},
  abstract = {Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different programming tasks. There have been many efforts to integrate static and dynamic typing and thereby combine the benefits of both typing disciplines in the same language. The flexibility of static typing can be improved by adding a type Dynamic and a typecase form. The safety and performance of dynamic typing can be improved by adding optional type annotations or by performing type inference (as in soft typing). However, there has been little formal work on type systems that allow a programmer-controlled migration between dynamic and static typing. Thatte proposed Quasi-Static Typing, but it does not statically catch all type errors in completely annotated programs. Anderson and Drossopoulou defined a nominal type system for an object-oriented language with optional type annotations. However, developing a sound, gradual type system for functional languages with structural types is an open problem.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/NKK4IH25/Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf}
}

@article{siekGradualTypingFunctional2006a,
  title = {Gradual {{Typing}} for {{Functional Languages}}},
  author = {Siek, Jeremy G and Taha, Walid},
  year = {2006},
  pages = {12},
  abstract = {Static and dynamic type systems have well-known strengths and weaknesses, and each is better suited for different programming tasks. There have been many efforts to integrate static and dynamic typing and thereby combine the benefits of both typing disciplines in the same language. The flexibility of static typing can be improved by adding a type Dynamic and a typecase form. The safety and performance of dynamic typing can be improved by adding optional type annotations or by performing type inference (as in soft typing). However, there has been little formal work on type systems that allow a programmer-controlled migration between dynamic and static typing. Thatte proposed Quasi-Static Typing, but it does not statically catch all type errors in completely annotated programs. Anderson and Drossopoulou defined a nominal type system for an object-oriented language with optional type annotations. However, developing a sound, gradual type system for functional languages with structural types is an open problem.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/JT5HC23M/Siek and Taha - 2006 - Gradual Typing for Functional Languages.pdf}
}

@inproceedings{sloaneMontoDisintegratedDevelopment2014,
  title = {Monto: {{A Disintegrated Development Environment}}},
  shorttitle = {Monto},
  booktitle = {Software {{Language Engineering}}},
  author = {Sloane, Anthony M. and Roberts, Matthew and Buckley, Scott and Muscat, Shaun},
  editor = {Combemale, Beno{\^i}t and Pearce, David J. and Barais, Olivier and Vinju, Jurgen J.},
  year = {2014},
  series = {Lecture {{Notes}} in {{Computer Science}}},
  pages = {211--220},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-11245-9_12},
  abstract = {Integrated development environments play a central role in the life of many software developers. Integrating new functionality into these environments is non-trivial and forms a significant barrier to entry. We describe our Monto architecture which aims to address this problem. Monto components communicate via text messages across an off-the-shelf messaging layer. The architecture imposes limited constraints which enables easy combination of components to form an environment. A prototype implementation shows that this approach is practical and shows promise for full-featured development environments.},
  isbn = {978-3-319-11245-9},
  langid = {english},
  keywords = {Abstract Syntax Tree,Integrate Development Environment,Message Format,Text Editor,Version Text},
  file = {/Users/ysander/Zotero/storage/QZA6K9Q3/Sloane et al. - 2014 - Monto A Disintegrated Development Environment.pdf}
}

@misc{SmartPointersRust,
  title = {Smart {{Pointers}} - {{The Rust Programming Language}}},
  url = {https://doc.rust-lang.org/book/ch15-00-smart-pointers.html},
  urldate = {2022-01-09},
  file = {/Users/ysander/Zotero/storage/T3M8RT3V/ch15-00-smart-pointers.html}
}

@misc{SoftwareVerificationGoogle,
  title = {Software {{Verification}} in the {{Google App-Engine Cloud}}},
  url = {https://www.sosy-lab.org/research/cpa-appengine/},
  urldate = {2022-02-24},
  file = {/Users/ysander/Zotero/storage/PSJDZWQ3/cpa-appengine.html}
}

@misc{StarlarkLanguage,
  title = {Starlark Language},
  url = {https://docs.bazel.build/versions/main/skylark/language.html},
  urldate = {2022-01-01},
  langid = {english}
}

@inproceedings{swiecickiHowServerSoftware2018,
  title = {How {{Is Server Software Configured}}? {{Examining}} the {{Structure}} of {{Configuration Files}}},
  shorttitle = {How {{Is Server Software Configured}}?},
  booktitle = {Information {{Systems Architecture}} and {{Technology}}: {{Proceedings}} of 38th {{International Conference}} on {{Information Systems Architecture}} and {{Technology}} \textendash{} {{ISAT}} 2017},
  author = {{\'S}wi{\k{e}}cicki, B{\l}a{\.z}ej and Borzemski, Leszek},
  editor = {Borzemski, Leszek and {\'S}wi{\k{a}}tek, Jerzy and Wilimowska, Zofia},
  year = {2018},
  series = {Advances in {{Intelligent Systems}} and {{Computing}}},
  pages = {217--229},
  publisher = {{Springer International Publishing}},
  address = {{Cham}},
  doi = {10.1007/978-3-319-67220-5_20},
  abstract = {Contemporary software on servers is usually configured through editing configuration files. Surprisingly, to the extent of our knowledge, the diversity of configuration file formats remains unstudied. Our goal in this work is to determine what data structures are used in configuration files and what formats are being used to encode them, in order to have a foundation for semantic analysis of their contents in the future. We examine 14133 files in 3409 packages comprising the whole set of software available in Debian stable repositories that has configuration files in the /etc directory. After eliminating files that are not configuration (such as init scripts), we assign them to categories using various criteria, some of them being the data structure they express or whether the order of statements matter. In this examination we find that even custom configuration formats can usually be expressed using one of several commonly used data structures. Some software packages, however, are configured in a Turing-complete programming language, usually the same one that the configured program was written in, and are therefore unsuitable for static analysis. Regardless, we provide a taxonomy of configuration formats, and highlight common themes in custom formats used by various packages. Ultimately, we describe a data structure that is able to hold information about all of these configuration files for further analysis.},
  isbn = {978-3-319-67220-5},
  langid = {english},
  keywords = {Configuration,Configuration management automation,Data modeling,Static analysis,System configuration},
  file = {/Users/ysander/Zotero/storage/SEJSLEB8/Święcicki and Borzemski - 2018 - How Is Server Software Configured Examining the S.pdf}
}

@misc{therustprogramminglanguageBringingGreatIDE,
  title = {Bringing a Great {{IDE}} Experience to the {{Rust}} Programming Language.},
  journal = {rust-analyzer},
  url = {https://rust-analyzer.github.io/},
  urldate = {2021-11-23},
  collaborator = {{The Rust Programming Language}},
  copyright = {Ferrous Systems \& contributors},
  file = {/Users/ysander/Zotero/storage/VDNPAVA5/rust-analyzer.github.io.html}
}

@misc{ThreeArchitecturesResponsive,
  title = {Three {{Architectures}} for a {{Responsive IDE}}},
  url = {https://rust-analyzer.github.io/blog/2020/07/20/three-architectures-for-responsive-ide.html},
  urldate = {2021-11-12},
  file = {/Users/ysander/Zotero/storage/TJD332SM/three-architectures-for-responsive-ide.html}
}

@misc{TowerlspCratesIo,
  title = {Tower-Lsp - Crates.Io: {{Rust Package Registry}}},
  url = {https://crates.io/crates/tower-lsp},
  urldate = {2021-07-28},
  file = {/Users/ysander/Zotero/storage/P6U2M9LS/tower-lsp.html}
}

@misc{TreatingSmartPointers,
  title = {Treating {{Smart Pointers Like Regular References}} with the {{Deref Trait}} - {{The Rust Programming Language}}},
  url = {https://doc.rust-lang.org/book/ch15-02-deref.html},
  urldate = {2022-01-09},
  file = {/Users/ysander/Zotero/storage/GIHQFIEX/ch15-02-deref.html}
}

@misc{UserManual,
  title = {User {{Manual}}},
  url = {https://rust-analyzer.github.io/manual.html#features},
  urldate = {2022-05-08},
  file = {/Users/ysander/Zotero/storage/9HRVQRF2/manual.html}
}

@misc{vaughan-nicholsOpensourceMicrosoftProtocol,
  title = {\hspace{0pt}{{Open-source Microsoft}} Protocol Aims to Be a Programming Standard},
  author = {{Vaughan-Nichols}, Steven},
  journal = {ZDNet},
  url = {https://www.zdnet.com/article/open-source-microsoft-protocol-aims-to-be-a-programming-standard/},
  urldate = {2021-12-28},
  abstract = {Codenvy, Microsoft, and Red Hat have announced they are adopting a universal Language Server Protocol for integrated development environments.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/XFV76FTH/open-source-microsoft-protocol-aims-to-be-a-programming-standard.html}
}

@article{visserFreshLookName,
  title = {A Fresh Look at Name Binding   in Programming Languages},
  author = {Visser, Eelco},
  pages = {55},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/3QX47I6X/Visser - A fresh look at name binding   in programming lang.pdf}
}

@misc{VisualStudioIDE,
  title = {Visual {{Studio}}: {{IDE}} and {{Code Editor}} for {{Software Developers}} and {{Teams}}},
  url = {https://visualstudio.microsoft.com/},
  urldate = {2022-05-01},
  file = {/Users/ysander/Zotero/storage/2LGZRFUS/visualstudio.microsoft.com.html}
}

@misc{vogeleclipse,
  title = {Eclipse Rich Client Platform. {{Vogella}} Series, Lars Vogel (2015)},
  author = {Vogel, Lars and Milinkovich, M}
}

@misc{W3CXMLSchema,
  title = {{{W3C XML Schema Definition Language}} ({{XSD}}) 1.1 {{Part}} 1: {{Structures}}},
  url = {https://www.w3.org/TR/xmlschema11-1/},
  urldate = {2022-01-02},
  file = {/Users/ysander/Zotero/storage/3SKX63JI/xmlschema11-1.html}
}

@incollection{wadlerWelltypedProgramsCan2009,
  title = {Well-Typed Programs Can't Be Blamed},
  booktitle = {Programming {{Languages}} and {{Systems}}},
  author = {Wadler, Philip and Findler, Robert Bruce},
  editor = {Castagna, Giuseppe},
  year = {2009},
  volume = {5502},
  pages = {1--16},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/978-3-642-00590-9_1},
  url = {http://link.springer.com/10.1007/978-3-642-00590-9_1},
  urldate = {2021-09-01},
  abstract = {We introduce the blame calculus, which adds the notion of blame from Findler and Felleisen's contracts to a system similar to Siek and Taha's gradual types and Flanagan's hybrid types. We characterise where positive and negative blame can arise by decomposing the usual notion of subtype into positive and negative subtypes, and show that these recombine to yield naive subtypes. Naive subtypes previously appeared in type systems that are unsound, but we believe this is the first time naive subtypes play a role in establishing type soundness.},
  isbn = {978-3-642-00589-3 978-3-642-00590-9},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/5SWC2GCH/Wadler and Findler - 2009 - Well-Typed Programs Can’t Be Blamed.pdf}
}

@article{wechsungFregeProgrammingLanguage,
  title = {The {{Frege Programming Language}} ({{Draft}})},
  author = {Wechsung, Ingo},
  pages = {124},
  url = {http://web.mit.edu/frege-lang_v3.24/Language.pdf},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/UQP4WWJQ/Wechsung - The Frege Programming Language (Draft).pdf}
}

@misc{WhatFrege2022,
  title = {What Is {{Frege}}?},
  year = {2022},
  month = may,
  url = {https://github.com/Frege/frege},
  urldate = {2022-05-01},
  abstract = {Frege is a Haskell for the JVM. It brings purely functional programing to the Java platform.},
  howpublished = {Frege}
}

@misc{WhatFregIDE2020,
  title = {What Is {{fregIDE}}?},
  year = {2020},
  month = jul,
  url = {https://github.com/Frege/eclipse-plugin},
  urldate = {2022-05-01},
  abstract = {The eclipse plugin for frege, codename fregIDE},
  howpublished = {Frege}
}

@article{xuFHIRPITOpen2020,
  title = {{{FHIR PIT}}: An Open Software Application for Spatiotemporal Integration of Clinical Data and Environmental Exposures Data},
  shorttitle = {{{FHIR PIT}}},
  author = {Xu, Hao and Cox, Steven and Stillwell, Lisa and Pfaff, Emily and Champion, James and Ahalt, Stanley C. and Fecho, Karamarie},
  year = {2020},
  month = mar,
  journal = {BMC Medical Informatics and Decision Making},
  volume = {20},
  number = {1},
  pages = {53},
  issn = {1472-6947},
  doi = {10.1186/s12911-020-1056-9},
  url = {https://doi.org/10.1186/s12911-020-1056-9},
  urldate = {2022-01-01},
  abstract = {Informatics tools to support the integration and subsequent interrogation of spatiotemporal data such as clinical data and environmental exposures data are lacking. Such tools are needed to support research in environmental health and any biomedical field that is challenged by the need for integrated spatiotemporal data to examine individual-level determinants of health and disease.},
  langid = {english},
  file = {/Users/ysander/Zotero/storage/NXQNA484/Xu et al. - 2020 - FHIR PIT an open software application for spatiot.pdf}
}


